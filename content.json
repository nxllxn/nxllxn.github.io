[{"title":"如何优雅的操作一个Json","date":"2017-05-31T07:19:23.076Z","path":"2017/05/31/java/java工具/NetSFJson/","text":"需求缘起JSON（JavaScript Object Notation）,是一种被广泛使用的后端数据处理以及前后端数据交互格式，本文将简要讨论一下如何中规中矩的操作一个JsonObject，从中读取数据，最后我也会简单介绍一下如何优雅地构建一个Json。 写在编码之前需求定义：1）从一个Json对象中读取Json属性，提供一个基本的读取函数get（返回值为Object），以及一些常用的类型如String，Double，Integer，Long，Boolean，JSONArray，JSONObject的读取函数2）为上述所有函数提供一个包含默认值的重载函数，当用户调用这个有默认值的函数时，编码更加清晰，程序的行为会更加明了3）虽然提供默认值程序会更加明了，但是上述两种解决方案还是可能导致大量空指针异常，为了对这个情况进行控制我们选择使用Optional（不了解的可参考guava类库以及Java8 Optional）来为上述函数统一提供一个Optional版本的重载（其实并不能叫重载，叫实现好一点，这里是为了凸显这三种实现的共性）。4）跨越多级Json取出指定属性5）原始的Json构造模式中代码不是很美观，而且如果你使用net.sf.json类库的话构造Json还可能出问题（之后会提到），所以本文最后会利用构造器模式来相对优雅地进行Json的组装。6）问题5中的一个问题，先声明，此问题只有net.sf.json中会出现，fastjson类库中没有上述问题。其它类库中TZ没有进行过研究。 编码首先是一个单例public class JSONTool { private JSONTool() { } private static class Holder { private static JSONTool jsonTool = new JSONTool(); } /** * 单例，才疏学浅，只会这么一个设计模式，哎 * * @return JsonTool对象 */ public static JSONTool getSingleInstance() { return Holder.jsonTool; } } 中规中矩的数据读取方式（包括带默认值的）/** * 判断当前Json对象中指定Key对应的json属性是否存在 * * @param dataJsonObj 当前jsonObject * @param key 指定json属性对应的key * @return 存在当前key返回true，否则返回false */ public Boolean isAttributeExists(JSONObject dataJsonObj, String key) { return !(dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) &amp;&amp; dataJsonObj.containsKey(key); } /** * 从当前json对象中取出指定key对应的布尔属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 返回指定key对应的布尔属性，如果指定key不存在或者不是一个有效的bool值，返回null */ public Boolean getBoolean(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } if (!REGUtil.REG_PATTERN_FOR_BOOLEAN.matcher(strValue).matches()) { return null; } return Boolean.valueOf(strValue); } /** * 从当前json对象中取出指定key对应的布尔属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 返回指定key对应的布尔属性，如果指定key不存在或者不是一个有效的bool值，返回defaultValue */ public Boolean getBoolean(JSONObject dataJsonObj, String key, Boolean defaultValue) { Boolean actualValue = getBoolean(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的双精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 如果指定key不存在或者不是一个有效的数值属性，返回null */ public Double getDouble(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(strValue).matches()) { return null; } return Double.valueOf(strValue.replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;)); } /** * 从指定Json对象中取出指定Key对应的数值属性值 * * @param dataJsonObj 指定Json对象 * @param key 指定Key * @param defaultValue 默认值 * @return 如果指定key对应的属性为有效的数值属性，那么返回此值，否则返回默认值defaultValue */ public Double getDouble(JSONObject dataJsonObj, String key, Double defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的金额属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 如果指定key不存在或者不是一个有效的金额属性，返回null */ public Double getAmount(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } //替换掉非数值字符 strValue = strValue.replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;); if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(strValue).matches()) { return null; } return Double.valueOf(strValue); } /** * 从指定Json对象中取出指定Key对应的金额属性值 * * @param dataJsonObj 指定Json对象 * @param key 指定Key * @param defaultValue 默认值 * @return 如果指定key对应的属性为有效的金额属性，那么返回此值，否则返回默认值defaultValue */ public Double getAmount(JSONObject dataJsonObj, String key, Double defaultValue) { Double actualValue = getAmount(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前对象中取出指定键对应的单精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的单精度浮点数属性，如果指定key不存在或者不是一个有效的数值属性，返回null */ public Float getFloat(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.floatValue(); } /** * 从当前对象中取出指定键对应的单精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的单精度浮点数属性，如果指定key不存在或者不是一个有效的数值属性，返回默认值 */ public Float getFloat(JSONObject dataJsonObj, String key, Float defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.floatValue(); } /** * 从当前对象中取出指定键对应的属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的属性，如果不存在或发生异常返回null */ public Object get(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty()) { return null; } if (!dataJsonObj.containsKey(key)) { return null; } return dataJsonObj.get(key); } /** * 从当前对象中取出指定键对应的属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的属性，如果不存在返回默认值 */ public Object get(JSONObject dataJsonObj, String key, Object defaultValue) { Object actualValue = get(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前对象中取出指定键对应的整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者指定属性不是一个有效的数值属性那么返回null */ public Integer getInteger(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.intValue(); } /** * 从当前对象中取出指定键对应的整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者指定属性不是一个有效的数值属性那么返回默认值 */ public Integer getInteger(JSONObject dataJsonObj, String key, Integer defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.intValue(); } /** * 从当前对象中取出指定键对应的长整型整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者不是一个有效的数值属性那么返回null */ public Long getLong(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.longValue(); } /** * 从当前对象中取出指定键对应的长整型整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者不是一个有效的数值属性那么返回默认值 */ public Long getLong(JSONObject dataJsonObj, String key, Long defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.longValue(); } /** * 从当前对象中取出指定键对应的json数组 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定key对应的json数组，如果指定对应的属性不存在或者不是json数组返回null */ public JSONArray getJsonArray(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || !(obj instanceof JSONArray)) { return null; } return (JSONArray) obj; } /** * 从当前对象中取出指定键对应的json数组 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定key对应的json数组，如果指定对应的属性不存在或者不是Json数组返回默认值 */ public JSONArray getJsonArray(JSONObject dataJsonObj, String key, JSONArray defaultValue) { JSONArray actualValue = getJsonArray(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的json对象 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定key对应的json对象属性，如果指定对应的属性不存在或者不是json对象返回null */ public JSONObject getJsonObject(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || !(obj instanceof JSONObject)) { return null; } return (JSONObject) obj; } /** * 从当前json对象中取出指定键对应的json对象 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定key对应的json对象属性，如果指定对应的属性不存在或者不是json对象返回默认值 */ public JSONObject getJsonObject(JSONObject dataJsonObj, String key, JSONObject defaultValue) { JSONObject actualValue = getJsonObject(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的字符串 * * @param dataJsonObj 当前jsonObject * @param key 指定key * @return 指定键对应的字符串，如果不存在返回null */ public String getString(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } if (!dataJsonObj.containsKey(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || obj instanceof JSON) { return null; } return String.valueOf(obj); } /** * 从当前json对象中取出指定键对应的字符串 * * @param dataJsonObj 当前jsonObject * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的字符串，如果不存在或者指定key对应的属性是一个Json对象或者是Json数组返回默认值 */ public String getString(JSONObject dataJsonObj, String key, String defaultValue) { String actualValue = getString(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } Optional方式的数据读取public Optional&lt;Object&gt; opt(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } BiFunction&lt;JSONObject,String,Optional&lt;Object&gt;&gt; optFunction = (x,y) -&gt; Stream.of(x.entrySet()) .flatMap(Collection::stream) .filter(z -&gt; ((Map.Entry)z).getKey().equals(y)) .map(z -&gt; ((Map.Entry)z).getValue()) .findAny(); return optFunction.apply(dataJsonObj,key); } public Optional&lt;String&gt; optString(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (obj instanceof JSON) { return Optional.empty(); } return Optional.of(String.valueOf(obj)); } /** * 返回Optional类型的Double属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Double属性 */ public Optional&lt;Double&gt; optDouble(JSONObject dataJsonObj,String key){ Optional&lt;String&gt; optStr = optString(dataJsonObj,key); if (!optStr.isPresent()){ return Optional.empty(); } if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(optStr.get()).matches()) { return Optional.empty(); } return Optional.of(Double.valueOf(optStr.get().replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;))); } /** * 返回Optional类型的Float属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Float属性 */ public Optional&lt;Float&gt; optFloat(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::floatValue); } /** * 返回Optional类型的Integer属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Integer属性 */ public Optional&lt;Integer&gt; optInteger(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::intValue); } /** * 返回Optional类型的Long属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Long属性 */ public Optional&lt;Long&gt; optLong(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::longValue); } /** * 返回Optional类型的Boolean属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Boolean属性 */ public Optional&lt;Boolean&gt; optBoolean(JSONObject dataJsonObj,String key) { Optional&lt;String&gt; optStr = optString(dataJsonObj,key); if (!optStr.isPresent()){ return Optional.empty(); } if (StringUtils.isEmpty(optStr.get())) { return Optional.empty(); } if (!REGUtil.REG_PATTERN_FOR_BOOLEAN.matcher(optStr.get()).matches()) { return Optional.empty(); } return Optional.of(Boolean.valueOf(optStr.get())); } /** * 返回Optional类型的JsonObject属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的JsonObject属性 */ public Optional&lt;JSONObject&gt; optJsonObj(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (!(obj instanceof JSONObject)){ return Optional.empty(); } return Optional.of((JSONObject)obj); } /** * 返回Optional类型的JsonArray属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的JsonArray属性 */ public Optional&lt;JSONArray&gt; optJsonObjs(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (!(obj instanceof JSONArray)){ return Optional.empty(); } return Optional.of((JSONArray)obj); } 跨越多级取出指定属性private static final String FIELD_EXPRESSION_SEPARATOR = &quot;&gt;&quot;; /** * 从指定Json对象中取出指定表达式对应的属性 * * @param dataJsonObj 指定Json对象 * @param operandExpression 指定属性表达式 * @return 指定字段对应的属性 */ public static Object metaGet(JSONObject dataJsonObj, String operandExpression) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(operandExpression)){ return null; } String[] operandExpressionParts = operandExpression.split(FIELD_EXPRESSION_SEPARATOR); Object obj = dataJsonObj; for (String operandExpressionPart : operandExpressionParts) { if (obj == null) { break; } if (obj instanceof JSONObject) { obj = ((JSONObject) obj).get(operandExpressionPart); continue; } if (obj instanceof JSONArray) { if (((JSONArray) obj).size() == 0) { return null; } obj = ((JSONArray) obj).get(0); if (obj instanceof JSONObject) { obj = ((JSONObject) obj).get(operandExpressionPart); } continue; } // 如果已经取到基本类型这一层了,但是表达式每一个小块儿还没用完,那么直接返回空,这是一个无效操作 return null; } return obj; } 构造Json/** * 构造器 */ public static class Builder { /** * 待构造Json对象 */ private Map&lt;String, Object&gt; currentMap; /** * 构造函数 */ public Builder() { this.currentMap = new HashMap&lt;&gt;(); } /** * 构造指定key-value-pair * * @param key 指定key * @param value 指定值 * @return 当前构造器对象 */ public Builder with(String key, Object value) { this.currentMap.put(key, value); return this; } /** * 构建Json对象 * * @return json对象 */ public JSONObject build() { return JSONObject.fromObject(this.currentMap); } } //使用方式 new JSONTool.Builder() .with(&quot;key_one&quot;,&quot;valueOne&quot;) .with(&quot;key_two&quot;,1) .with(&quot;key_three&quot;,true) .with(&quot;key_four&quot;,new JSONTool.Builder().with(&quot;sub_key_one&quot;,&quot;subValueOne&quot;).build()) .build(); net.sf.json的深复制问题大家应该也注意到上面的Builder中我并没有直接使用JsonObject作为属性，而是使用Map。为什么呢，我们看一下下面的例子，大家就明白了。 net.sf.jsonMap&lt;String, Object&gt; rootMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapOne = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapTwo = new HashMap&lt;&gt;(); subMapOne.put(&quot;map&quot;,subMapTwo); rootMap.put(&quot;map&quot;,subMapOne); System.out.println(rootMap); //{map={map={}}} subMapTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootMap); //{map={map={xxx=xxx}}} JSONObject rootJsonObj = new JSONObject(); JSONObject subJsonObjOne = new JSONObject(); JSONObject subJsonObjTwo = new JSONObject(); subJsonObjOne.put(&quot;json&quot;,subJsonObjTwo); rootJsonObj.put(&quot;json&quot;,subJsonObjOne); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} subJsonObjTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} What are you 弄啥嘞？ com.alibaba.fastjsonMap&lt;String, Object&gt; rootMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapOne = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapTwo = new HashMap&lt;&gt;(); subMapOne.put(&quot;map&quot;,subMapTwo); rootMap.put(&quot;map&quot;,subMapOne); System.out.println(rootMap); //{map={map={}}} subMapTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootMap); //{map={map={xxx=xxx}}} JSONObject rootJsonObj = new JSONObject(); JSONObject subJsonObjOne = new JSONObject(); JSONObject subJsonObjTwo = new JSONObject(); subJsonObjOne.put(&quot;json&quot;,subJsonObjTwo); rootJsonObj.put(&quot;json&quot;,subJsonObjOne); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} subJsonObjTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{&quot;xxx&quot;:&quot;xxx&quot;}}} ：)","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"JSON工具","slug":"JSON工具","permalink":"http://nxllxn.github.io/tags/JSON工具/"},{"name":"JSONTool","slug":"JSONTool","permalink":"http://nxllxn.github.io/tags/JSONTool/"}]},{"title":"如何优雅地实现一个Java日期转换工具","date":"2017-05-27T07:26:45.951Z","path":"2017/05/27/java/java工具/DateTool/","text":"需求缘起 日常编程过程中或多或少需要用到日期转换相关的功能，比如常用格式相关的日期格式化为字符串或者是字符串转日期对象等，甚至有的时候需要一个兼容较多日期格式的字符串转日期方法，本文中我会实现一个基本满足上述功能的简单工具。 为什么要实现为一个工具而不是一个工具类呢。首先声明工具类和工具是有区别的，工具类是指XXXUtil这种命名的类，其内部通常包含一组功能相近或者相似的静态工具函数，注意了这里是静态工具函数。而工具是指以XXXTool这种命名的类，这种类通常是可实例化的，且内部有一组功能相近或者相似的实例方法。好吧，扯了这么多，其实大概意思就是我会用上一点点面向对象的设计思路。具体为什么要这样，看完本文你就会大概了解我的初衷的。 写在编码之前任何一份好的代码都必然是经过两次加工，第一次是在脑子里面，我不建议拿到需求就里面开始编码，首先你要把需求整个过一遍，在大脑里面有个大概的思路，此外，程序是写来处理异常情况的，为什么有“测试驱动编程”，就是我们先明确我们的代码需要处理的全部流程，需要的功能是什么，有哪些异常情况需要处理等等，做到这一步才能说我们理解了需求。 基本功能，基本的字符串转日期功能，基本的日期格式化为字符串功能，一个可以兼容多种日期格式的字符串转日期功能。 为了方便使用，可以为一些常用的格式转换提供默认实现 面向对象编程，提供一组接口，提供这个接口的不同实现，为什么不同？之后再告诉你！ 单例，我计划将这个工具设计为一个单例 线程安全，每次new一个日期转换工具类太麻烦而且浪费资源，我们会对日期格式化相关的对象做一个“缓存”。什么缓存，直接维护几个全局静态的实例不就好了吗？不！SimpleDateFormat不是线程安全的，在并发环境下这种实现就会出问题。那正确的姿势是什么呢？本文中我会使用ThreadLocal！ 单元测试，这里把单元测试列为设计实现的一部分，首先单元测试的重要性我们就不说了，主要是代码写完了，是骡子是马，总得遛一遛看一下对不对。 编码接口定义不多说了，直接上代码 public interface DateTool { /** * 日志TAG */ String TAG = &quot;DateTool&quot;; /** * 默认的日期格式 */ String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; /** * 默认月份格式 */ String DEFAULT_MONTH_FORMAT = &quot;yyyy-MM&quot;; /** * 默认年份格式 */ String DEFAULT_YEAR_FORMAT = &quot;yyyy&quot;; /** * 默认的时间格式 */ String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; /** * 默认的日期时间格式 */ String DEFAULT_DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; /** * 如果字符串长度为8位，且都是字符串，那么我们认为这是一个yyyyMMdd格式的日期 */ Pattern FULL_DATE_PATTERN = Pattern.compile(&quot;[0-9]{8}&quot;); //20120101 /** * 日期分隔符 */ String DATE_NOTIFIER_PATTERN_STR = &quot;[年月日\\\\-/.]+&quot;; /** * 时间分隔符 */ String TIME_NOTIFIER_PATTERN_STR = &quot;[时分秒点:]+&quot;; /** * 压缩的时间日期格式 */ String DATA_TIME_FORMAT = &quot;yyyyMMddHHmmss&quot;; /** * 压缩的日期格式 */ String DATA_FORMAT = &quot;yyyyMMdd&quot;; /** * 压缩的时间格式 */ String TIME_FORMAT = &quot;HHmmss&quot;; Pattern REG_PATTERN_FOR_DATE = Pattern.compile( &quot;((^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(10|12|0?[13578])([-/\\\\._])(3[01]|[12][0-9]|0?[1-9]).*$)&quot; + &quot;|(^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(11|0?[469])([-/\\\\._])(30|[12][0-9]|0?[1-9]).*$)&quot; + &quot;|(^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(0?2)([-/\\\\._])(2[0-8]|1[0-9]|0?[1-9]).*$)&quot; + &quot;|(^([2468][048]00)([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([3579][26]00)([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][0][48])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][0][48])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][2468][048])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][2468][048])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][13579][26])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][13579][26])([-/\\\\._])(0?2)([-/\\\\._])(29).*$))&quot;); /** * 使用指定格式化字符转换指定日期字符串 * * @param dateTimeStr 指定日期字符串 * @return 转换后得到的date */ Date parse(String dateTimeStr) throws Exception ; /** * 使用指定格式化字符转换指定日期字符串 * * @param dateString 指定日期字符串 * @param parseStr 指定格式化字符 * @return 转换后得到的date */ Date parse(String parseStr, String dateString) throws Exception ; /** * 按照指定字符串格式格式化指定日期 * @param pattern 字符串格式 * @param date 指定日期 * @return 格式化后的字符串 */ String format(String pattern, Date date) throws Exception ; /** * 使用默认日期格式转换指定日期字符换 * * @param dateString 指定日期字符串 * @return 转换后得到的date */ Date parseDate(String dateString) throws Exception ; /** * 使用默认日期格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatDate(Date date) throws Exception ; /** * 使用默认时间格式转换时间字符串 * * @param dateString 时间字符串 * @return 转换后得到的date */ Date parseTime(String dateString) throws Exception ; /** * 使用默认时间格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatTime(Date date) throws Exception ; /** * 使用默认格式转换指定日期时间字符串 * * @param dateString 指定日期时间字符串 * @return 转换后得到的date */ Date parseDateTime(String dateString) throws Exception ; /** * 使用默认日期时间格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatDateTime(Date date) throws Exception ; } 里面有比较详细的JavaDoc，我大概说一下 程序开始定义了一些常用的日期格式字符串常量 接下来是相关接口一共有9个接口： Date parse(String dateTimeStr);兼容多种日期格式的字符串转日期接口 Date parse(String parseStr, String dateString) ;使用指定格式化字符parseStr转换指定日期字符串dateString Date parseDate(String dateString) ; 使用默认日期格式转换指定日期字符换 Date parseTime(String dateString) ; 使用默认时间格式转换时间字符串 Date parseDateTime(String dateString) ; 使用默认日期时间格式转换指定日期时间字符串 String format(String pattern, Date date); 按照指定字符串格式格式化指定日期 String formatDate(Date date); 使用默认日期格式格式化date String formatTime(Date date) ; 使用默认时间格式格式化date String formatDateTime(Date date); 使用默认日期时间格式格式化date 一个字，清晰！明了！好了接下来就是具体实现了。 ThreadLocal实现时间转换格式“缓存”还是先上代码 public class BaseDateTool { /** * ThreadLocal 对象,用于存储当前线程中使用的日期格式化对象 */ private static final ThreadLocal convertDataFormatThreadLocal = new ThreadLocal(); /** * 获取或者实例化一个指定字符串格式对应的SimpleDateFormat对象 * @param pattern 格式化字符串 * @return 格式化字符串对应的SimpleDateFormat格式化对象 */ protected SimpleDateFormat getDateFormat(String pattern) throws Exception{ Map&lt;String,SimpleDateFormat&gt; map = (Map&lt;String, SimpleDateFormat&gt;) convertDataFormatThreadLocal.get(); if(map == null){ map = new HashMap&lt;&gt;(); map.put(pattern,new SimpleDateFormat(pattern)); convertDataFormatThreadLocal.set(map); } if(!map.containsKey(pattern)){ map.put(pattern,new SimpleDateFormat(pattern)); } return map.get(pattern); } } 这是具体实现类的一个基类，既然接口都抽出来了，把这一块功能抽离到一个基类里面好像也不过份吧。简单解释一下，首先声明了一个全局的静态的final的ThreadLocal对象，不用说了，我们用于日期转换格式化的SimpleDateFormat对象就会放到这里面。那么问题来了，怎么放呢，实际编码过程中，可能遇到各种类型的日期格式需要进行格式化或者转换。所以我们用一个Map来存储这些对象，key为实际的字符串格式，值为当前字符串格式对应的日期转换格式化对象，如果Map中已经存在了指定字符串格式的key，那么直接将这个key对应的对象返回，否则先new一个当前格式的对象，然后插入到Map中并返回。 具体实现老规矩，先上代码。 public class DateToolImpl extends BaseDateTool implements DateTool{ private DateToolImpl(){} private static class Holder{ private static final DateTool dateTool = new DateToolImpl(); } public static DateTool getSiingleInstance(){ return Holder.dateTool; } @Override public Date parse(String dateTimeStr) throws Exception { if (StringUtils.isEmpty(dateTimeStr)) { return null; } dateTimeStr = dateTimeStr.replaceAll(&quot;\\\\.\\\\d{3}&quot;, &quot;&quot;); //去除掉毫秒部分 String dateStr = null; String timeStr = null; String[] dateTimeStrParts = dateTimeStr.split(&quot;[ \\\\n]&quot;); for (String dateTimeStrPart : dateTimeStrParts) { if (REG_PATTERN_FOR_DATE.matcher(dateTimeStrPart).matches() || dateTimeStrPart.contains(&quot;年&quot;) || dateTimeStrPart.contains(&quot;月&quot;) || dateTimeStrPart.contains(&quot;日&quot;) || dateTimeStrPart.contains(&quot;-&quot;) || dateTimeStrPart.contains(&quot;/&quot;) || dateTimeStrPart.contains(&quot;.&quot;) || FULL_DATE_PATTERN.matcher(dateTimeStrPart).matches() || dateTimeStrPart.length() == 4) { dateStr = dateTimeStrPart; } else { timeStr = dateTimeStrPart; } } StringBuilder dateBuilder = new StringBuilder(); if (!StringUtils.isEmpty(dateStr)) { String[] dateParts = dateStr.split(DATE_NOTIFIER_PATTERN_STR); for (String datePart : dateParts) { if (datePart.length() == 1) { dateBuilder.append(&quot;0&quot;); } dateBuilder.append(datePart); } switch (dateBuilder.length()) { case 4: dateBuilder.append(&quot;0101&quot;); break; case 6: dateBuilder.append(&quot;01&quot;); break; } } StringBuilder timeBuilder = new StringBuilder(); if (!StringUtils.isEmpty(timeStr)) { String[] timeParts = timeStr.split(TIME_NOTIFIER_PATTERN_STR); for (String timePart : timeParts) { if (timePart.length() == 1) { timeBuilder.append(&quot;0&quot;); } timeBuilder.append(timePart); } switch (timeBuilder.length()) { case 2: timeBuilder.append(&quot;0000&quot;); break; case 4: timeBuilder.append(&quot;00&quot;); break; } } String formattedDateStr = dateBuilder.toString(); String formattedTimeStr = timeBuilder.toString(); if (StringUtils.isEmpty(formattedDateStr) &amp;&amp; StringUtils.isEmpty(formattedTimeStr)) { return null; } if (StringUtils.isEmpty(formattedDateStr)) { return parse(TIME_FORMAT,formattedTimeStr); } if (StringUtils.isEmpty(formattedTimeStr)) { return parse(DATA_FORMAT,formattedDateStr); } return parse(DATA_TIME_FORMAT,formattedDateStr + formattedTimeStr); } @Override public Date parse(String parseStr, String dateString) throws Exception { if(StringUtils.isEmpty(parseStr) || StringUtils.isEmpty(dateString)){ return null; } return getDateFormat(parseStr).parse(dateString); } @Override public String format(String pattern, Date date) throws Exception { if(StringUtils.isEmpty(pattern) || date == null){ return null; } return getDateFormat(pattern).format(date); } @Override public Date parseDate(String dateString) throws Exception { return parse(DEFAULT_DATE_FORMAT, dateString); } @Override public String formatDate(Date date) throws Exception { return format(DEFAULT_DATE_FORMAT, date); } @Override public Date parseTime(String dateString) throws Exception { return parse(DEFAULT_TIME_FORMAT, dateString); } @Override public String formatTime(Date date) throws Exception { return format(DEFAULT_TIME_FORMAT, date); } @Override public Date parseDateTime(String dateString) throws Exception { return parse(DEFAULT_DATETIME_FORMAT, dateString); } @Override public String formatDateTime(Date date) throws Exception { return format(DEFAULT_DATETIME_FORMAT, date); } } 具体实现细节我就不再多讲了，上面的每个实现都不是很复杂。 测试DateTool dateTool = DateToolImpl.getSingleInstance(); @Test @SuppressWarnings(&quot;unchecked&quot;) public void testIntelligentParse(){ assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;20120202&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-02&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-2&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年2月2日&quot;).toString()); assertEquals(&quot;Thu Feb 02 01:01:01 CST 2012&quot;,dateTool.parse(&quot;2012-02-02 01:01:01&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012/02/02&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-02&quot;).toString()); assertEquals(&quot;Thu Jan 01 20:12:02 CST 1970&quot;,dateTool.parse(&quot;201202&quot;).toString()); assertEquals(&quot;Sun Jan 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012&quot;).toString()); assertEquals(&quot;Sun Jan 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年02月&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012.02.01&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012.02&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:11:11 CST 1970&quot;,dateTool.parse(&quot;11:11:11&quot;).toString()); assertEquals(&quot;Thu Jan 01 01:01:01 CST 1970&quot;,dateTool.parse(&quot;1:1:1&quot;).toString()); assertEquals(&quot;Thu Jan 01 01:01:01 CST 1970&quot;,dateTool.parse(&quot;01:01:01&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:11:00 CST 1970&quot;,dateTool.parse(&quot;11:11&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:00:00 CST 1970&quot;,dateTool.parse(&quot;11&quot;).toString()); } 结果：上面的单元测试都可以通过 //测试多线程 public static void main(String[] args) { DateTool dateTool = DateToolImpl.getSingleInstance(); for (int index = 0;index &lt; 10;index ++){ new Thread(() -&gt; { String currentThreadName = Thread.currentThread().getName(); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;20120202&quot;)); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;11:11:11&quot;)); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;2012年02月02日 11:11:11&quot;)); }).start(); } } 结果： Thread-7 Thu Feb 02 00:00:00 CST 2012 Thread-8 Thu Feb 02 00:00:00 CST 2012 Thread-2 Thu Feb 02 00:00:00 CST 2012 Thread-7 Thu Jan 01 11:11:11 CST 1970 Thread-2 Thu Jan 01 11:11:11 CST 1970 Thread-3 Thu Feb 02 00:00:00 CST 2012 Thread-5 Thu Feb 02 00:00:00 CST 2012 Thread-3 Thu Jan 01 11:11:11 CST 1970 Thread-5 Thu Jan 01 11:11:11 CST 1970 Thread-6 Thu Feb 02 00:00:00 CST 2012 Thread-0 Thu Feb 02 00:00:00 CST 2012 Thread-3 Thu Feb 02 11:11:11 CST 2012 Thread-2 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Feb 02 00:00:00 CST 2012 Thread-4 Thu Feb 02 00:00:00 CST 2012 Thread-1 Thu Feb 02 00:00:00 CST 2012 Thread-0 Thu Jan 01 11:11:11 CST 1970 Thread-7 Thu Feb 02 11:11:11 CST 2012 Thread-1 Thu Jan 01 11:11:11 CST 1970 Thread-8 Thu Jan 01 11:11:11 CST 1970 Thread-0 Thu Feb 02 11:11:11 CST 2012 Thread-1 Thu Feb 02 11:11:11 CST 2012 Thread-8 Thu Feb 02 11:11:11 CST 2012 Thread-6 Thu Jan 01 11:11:11 CST 1970 Thread-5 Thu Feb 02 11:11:11 CST 2012 Thread-4 Thu Jan 01 11:11:11 CST 1970 Thread-6 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Jan 01 11:11:11 CST 1970 Thread-4 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Feb 02 11:11:11 CST 2012 为什么要定义接口我们为需要实现的功能定义了接口，并提供了一种实现。但是有些时候可能需要另一种实现。比如java8中提供了一组新的Date Api，比如日期格式化类DateTimeFormatter。如果我们希望利用Java8 Date api做一个新的实现，那么就可以在不改变原来代码的情况下直接扩展一个实现就好了。 结语只是一个小demo，代码写的不好，有什么问题恳请批评指正，感激涕零！此外，请轻喷！ 参考资料深入理解Java：SimpleDateFormat安全的时间格式化","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"日期转换工具","slug":"日期转换工具","permalink":"http://nxllxn.github.io/tags/日期转换工具/"},{"name":"日期格式化工具","slug":"日期格式化工具","permalink":"http://nxllxn.github.io/tags/日期格式化工具/"},{"name":"DateTool","slug":"DateTool","permalink":"http://nxllxn.github.io/tags/DateTool/"}]},{"title":"随笔","date":"2017-05-19T03:08:48.971Z","path":"2017/05/19/essay/essay/","text":"不如意事常八九，可与人言无二三。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://nxllxn.github.io/tags/随笔/"}]}]