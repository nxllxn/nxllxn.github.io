[{"title":"如何优雅的操作一个Json","date":"2017-07-12T08:12:12.385Z","path":"2017/07/12/java/java工具/NetSFJson/","text":"需求缘起JSON（JavaScript Object Notation）,是一种被广泛使用的后端数据处理以及前后端数据交互格式，本文将简要讨论一下如何中规中矩的操作一个JsonObject，从中读取数据，最后我也会简单介绍一下如何优雅地构建一个Json。 写在编码之前需求定义：1）从一个Json对象中读取Json属性，提供一个基本的读取函数get（返回值为Object），以及一些常用的类型如String，Double，Integer，Long，Boolean，JSONArray，JSONObject的读取函数2）为上述所有函数提供一个包含默认值的重载函数，当用户调用这个有默认值的函数时，编码更加清晰，程序的行为会更加明了3）虽然提供默认值程序会更加明了，但是上述两种解决方案还是可能导致大量空指针异常，为了对这个情况进行控制我们选择使用Optional（不了解的可参考guava类库以及Java8 Optional）来为上述函数统一提供一个Optional版本的重载（其实并不能叫重载，叫实现好一点，这里是为了凸显这三种实现的共性）。4）跨越多级Json取出指定属性5）原始的Json构造模式中代码不是很美观，而且如果你使用net.sf.json类库的话构造Json还可能出问题（之后会提到），所以本文最后会利用构造器模式来相对优雅地进行Json的组装。6）问题5中的一个问题，先声明，此问题只有net.sf.json中会出现，fastjson类库中没有上述问题。其它类库中TZ没有进行过研究。 编码首先是一个单例public class JSONTool { private JSONTool() { } private static class Holder { private static JSONTool jsonTool = new JSONTool(); } /** * 单例，才疏学浅，只会这么一个设计模式，哎 * * @return JsonTool对象 */ public static JSONTool getSingleInstance() { return Holder.jsonTool; } } 中规中矩的数据读取方式（包括带默认值的）/** * 判断当前Json对象中指定Key对应的json属性是否存在 * * @param dataJsonObj 当前jsonObject * @param key 指定json属性对应的key * @return 存在当前key返回true，否则返回false */ public Boolean isAttributeExists(JSONObject dataJsonObj, String key) { return !(dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) &amp;&amp; dataJsonObj.containsKey(key); } /** * 从当前json对象中取出指定key对应的布尔属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 返回指定key对应的布尔属性，如果指定key不存在或者不是一个有效的bool值，返回null */ public Boolean getBoolean(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } if (!REGUtil.REG_PATTERN_FOR_BOOLEAN.matcher(strValue).matches()) { return null; } return Boolean.valueOf(strValue); } /** * 从当前json对象中取出指定key对应的布尔属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 返回指定key对应的布尔属性，如果指定key不存在或者不是一个有效的bool值，返回defaultValue */ public Boolean getBoolean(JSONObject dataJsonObj, String key, Boolean defaultValue) { Boolean actualValue = getBoolean(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的双精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 如果指定key不存在或者不是一个有效的数值属性，返回null */ public Double getDouble(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(strValue).matches()) { return null; } return Double.valueOf(strValue.replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;)); } /** * 从指定Json对象中取出指定Key对应的数值属性值 * * @param dataJsonObj 指定Json对象 * @param key 指定Key * @param defaultValue 默认值 * @return 如果指定key对应的属性为有效的数值属性，那么返回此值，否则返回默认值defaultValue */ public Double getDouble(JSONObject dataJsonObj, String key, Double defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的金额属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 如果指定key不存在或者不是一个有效的金额属性，返回null */ public Double getAmount(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } //替换掉非数值字符 strValue = strValue.replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;); if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(strValue).matches()) { return null; } return Double.valueOf(strValue); } /** * 从指定Json对象中取出指定Key对应的金额属性值 * * @param dataJsonObj 指定Json对象 * @param key 指定Key * @param defaultValue 默认值 * @return 如果指定key对应的属性为有效的金额属性，那么返回此值，否则返回默认值defaultValue */ public Double getAmount(JSONObject dataJsonObj, String key, Double defaultValue) { Double actualValue = getAmount(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前对象中取出指定键对应的单精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的单精度浮点数属性，如果指定key不存在或者不是一个有效的数值属性，返回null */ public Float getFloat(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.floatValue(); } /** * 从当前对象中取出指定键对应的单精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的单精度浮点数属性，如果指定key不存在或者不是一个有效的数值属性，返回默认值 */ public Float getFloat(JSONObject dataJsonObj, String key, Float defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.floatValue(); } /** * 从当前对象中取出指定键对应的属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的属性，如果不存在或发生异常返回null */ public Object get(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty()) { return null; } if (!dataJsonObj.containsKey(key)) { return null; } return dataJsonObj.get(key); } /** * 从当前对象中取出指定键对应的属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的属性，如果不存在返回默认值 */ public Object get(JSONObject dataJsonObj, String key, Object defaultValue) { Object actualValue = get(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前对象中取出指定键对应的整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者指定属性不是一个有效的数值属性那么返回null */ public Integer getInteger(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.intValue(); } /** * 从当前对象中取出指定键对应的整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者指定属性不是一个有效的数值属性那么返回默认值 */ public Integer getInteger(JSONObject dataJsonObj, String key, Integer defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.intValue(); } /** * 从当前对象中取出指定键对应的长整型整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者不是一个有效的数值属性那么返回null */ public Long getLong(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.longValue(); } /** * 从当前对象中取出指定键对应的长整型整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者不是一个有效的数值属性那么返回默认值 */ public Long getLong(JSONObject dataJsonObj, String key, Long defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.longValue(); } /** * 从当前对象中取出指定键对应的json数组 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定key对应的json数组，如果指定对应的属性不存在或者不是json数组返回null */ public JSONArray getJsonArray(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || !(obj instanceof JSONArray)) { return null; } return (JSONArray) obj; } /** * 从当前对象中取出指定键对应的json数组 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定key对应的json数组，如果指定对应的属性不存在或者不是Json数组返回默认值 */ public JSONArray getJsonArray(JSONObject dataJsonObj, String key, JSONArray defaultValue) { JSONArray actualValue = getJsonArray(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的json对象 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定key对应的json对象属性，如果指定对应的属性不存在或者不是json对象返回null */ public JSONObject getJsonObject(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || !(obj instanceof JSONObject)) { return null; } return (JSONObject) obj; } /** * 从当前json对象中取出指定键对应的json对象 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定key对应的json对象属性，如果指定对应的属性不存在或者不是json对象返回默认值 */ public JSONObject getJsonObject(JSONObject dataJsonObj, String key, JSONObject defaultValue) { JSONObject actualValue = getJsonObject(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的字符串 * * @param dataJsonObj 当前jsonObject * @param key 指定key * @return 指定键对应的字符串，如果不存在返回null */ public String getString(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } if (!dataJsonObj.containsKey(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || obj instanceof JSON) { return null; } return String.valueOf(obj); } /** * 从当前json对象中取出指定键对应的字符串 * * @param dataJsonObj 当前jsonObject * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的字符串，如果不存在或者指定key对应的属性是一个Json对象或者是Json数组返回默认值 */ public String getString(JSONObject dataJsonObj, String key, String defaultValue) { String actualValue = getString(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } Optional方式的数据读取public Optional&lt;Object&gt; opt(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } return Option.of(get(dataJsonObj,key)); } public Optional&lt;String&gt; optString(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (obj instanceof JSON) { return Optional.empty(); } return Optional.of(String.valueOf(obj)); } /** * 返回Optional类型的Double属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Double属性 */ public Optional&lt;Double&gt; optDouble(JSONObject dataJsonObj,String key){ Optional&lt;String&gt; optStr = optString(dataJsonObj,key); if (!optStr.isPresent()){ return Optional.empty(); } if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(optStr.get()).matches()) { return Optional.empty(); } return Optional.of(Double.valueOf(optStr.get().replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;))); } /** * 返回Optional类型的Float属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Float属性 */ public Optional&lt;Float&gt; optFloat(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::floatValue); } /** * 返回Optional类型的Integer属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Integer属性 */ public Optional&lt;Integer&gt; optInteger(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::intValue); } /** * 返回Optional类型的Long属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Long属性 */ public Optional&lt;Long&gt; optLong(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::longValue); } /** * 返回Optional类型的Boolean属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Boolean属性 */ public Optional&lt;Boolean&gt; optBoolean(JSONObject dataJsonObj,String key) { Optional&lt;String&gt; optStr = optString(dataJsonObj,key); if (!optStr.isPresent()){ return Optional.empty(); } if (StringUtils.isEmpty(optStr.get())) { return Optional.empty(); } if (!REGUtil.REG_PATTERN_FOR_BOOLEAN.matcher(optStr.get()).matches()) { return Optional.empty(); } return Optional.of(Boolean.valueOf(optStr.get())); } /** * 返回Optional类型的JsonObject属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的JsonObject属性 */ public Optional&lt;JSONObject&gt; optJsonObj(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (!(obj instanceof JSONObject)){ return Optional.empty(); } return Optional.of((JSONObject)obj); } /** * 返回Optional类型的JsonArray属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的JsonArray属性 */ public Optional&lt;JSONArray&gt; optJsonObjs(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (!(obj instanceof JSONArray)){ return Optional.empty(); } return Optional.of((JSONArray)obj); } 跨越多级取出指定属性private static final String FIELD_EXPRESSION_SEPARATOR = &quot;&gt;&quot;; /** * 从指定Json对象中取出指定表达式对应的属性 * * @param dataJsonObj 指定Json对象 * @param operandExpression 指定属性表达式 * @return 指定字段对应的属性 */ public static Object metaGet(JSONObject dataJsonObj, String operandExpression) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(operandExpression)){ return null; } String[] operandExpressionParts = operandExpression.split(FIELD_EXPRESSION_SEPARATOR); Object obj = dataJsonObj; for (String operandExpressionPart : operandExpressionParts) { if (obj == null) { break; } if (obj instanceof JSONObject) { obj = ((JSONObject) obj).get(operandExpressionPart); continue; } if (obj instanceof JSONArray) { if (((JSONArray) obj).size() == 0) { return null; } obj = ((JSONArray) obj).get(0); if (obj instanceof JSONObject) { obj = ((JSONObject) obj).get(operandExpressionPart); } continue; } // 如果已经取到基本类型这一层了,但是表达式每一个小块儿还没用完,那么直接返回空,这是一个无效操作 return null; } return obj; } 构造Json/** * 构造器 */ public static class Builder { /** * 待构造Json对象 */ private Map&lt;String, Object&gt; currentMap; /** * 构造函数 */ public Builder() { this.currentMap = new HashMap&lt;&gt;(); } /** * 构造指定key-value-pair * * @param key 指定key * @param value 指定值 * @return 当前构造器对象 */ public Builder with(String key, Object value) { this.currentMap.put(key, value); return this; } /** * 构建Json对象 * * @return json对象 */ public JSONObject build() { return JSONObject.fromObject(this.currentMap); } } //使用方式 new JSONTool.Builder() .with(&quot;key_one&quot;,&quot;valueOne&quot;) .with(&quot;key_two&quot;,1) .with(&quot;key_three&quot;,true) .with(&quot;key_four&quot;,new JSONTool.Builder().with(&quot;sub_key_one&quot;,&quot;subValueOne&quot;).build()) .build(); net.sf.json的深复制问题大家应该也注意到上面的Builder中我并没有直接使用JsonObject作为属性，而是使用Map。为什么呢，我们看一下下面的例子，大家就明白了。 net.sf.jsonMap&lt;String, Object&gt; rootMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapOne = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapTwo = new HashMap&lt;&gt;(); subMapOne.put(&quot;map&quot;,subMapTwo); rootMap.put(&quot;map&quot;,subMapOne); System.out.println(rootMap); //{map={map={}}} subMapTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootMap); //{map={map={xxx=xxx}}} JSONObject rootJsonObj = new JSONObject(); JSONObject subJsonObjOne = new JSONObject(); JSONObject subJsonObjTwo = new JSONObject(); subJsonObjOne.put(&quot;json&quot;,subJsonObjTwo); rootJsonObj.put(&quot;json&quot;,subJsonObjOne); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} subJsonObjTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} What are you 弄啥嘞？ com.alibaba.fastjsonMap&lt;String, Object&gt; rootMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapOne = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapTwo = new HashMap&lt;&gt;(); subMapOne.put(&quot;map&quot;,subMapTwo); rootMap.put(&quot;map&quot;,subMapOne); System.out.println(rootMap); //{map={map={}}} subMapTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootMap); //{map={map={xxx=xxx}}} JSONObject rootJsonObj = new JSONObject(); JSONObject subJsonObjOne = new JSONObject(); JSONObject subJsonObjTwo = new JSONObject(); subJsonObjOne.put(&quot;json&quot;,subJsonObjTwo); rootJsonObj.put(&quot;json&quot;,subJsonObjOne); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} subJsonObjTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{&quot;xxx&quot;:&quot;xxx&quot;}}} ：)","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"JSON工具","slug":"JSON工具","permalink":"http://nxllxn.github.io/tags/JSON工具/"},{"name":"JSONTool","slug":"JSONTool","permalink":"http://nxllxn.github.io/tags/JSONTool/"}]},{"title":"Linux 命令行","date":"2017-06-27T12:15:03.350Z","path":"2017/06/27/linux/linux命令行/LinuxCommandLine/","text":"启动，停止 启动： Ctrl + Alt + T 鼠标右键–&gt;在命令行中打开 停止： exit 文件系统跳转 pwd Print name of current working directory! 打印当前工作目录名称 cd Change Directory 更改当前工作目录路径 cd 无任何参数 更改当前工作目录到你的home目录 cd - 更改当前工作目录到先前工作目录 cd ～username 更改工作目录到指定用户主目录 探究操作系统 ls List current directory content 列出当前目录内容 ls -a/-all 列出所有文件，包括所有以.开头默认被隐藏的文件 ls -d/-directory 列出指定目录中的全部内容而不是当前目录 ls -F/-classify 此命令会为每个条目后面加上一个标识符，比如文件夹‘/’ ls -h/-human-readable 此命令以便于人眼阅读的模式展示文件信息，比如文件大小为KB或者，MB，而不是bytes ls -l 以长格式现实文件信息，一行一个文件 示例：-rw-r–r– 1 zhangsan zhangsan 0 4月1921:24 xx.ts -rw-r–r– 文件访问权限，开头的“-”说明是一个普通文件,“d”表明是一个目录。其后三个字符是文件所有者的访问权限,再其后的三个字符是文件所属组中成员的访问权限,最后三个字符是其他所有人的访问权限 1 文件硬连接的数目 zhangsan 文件所属用户名称 zhangsan 文件所属用户组名称 0 以字节数展示的文件大小 4月1921:24 最后一次文件修改时间 xx.ts 文件名称 ls -r/-reverse 以相反的顺序展示文件，默认是按照字母表升序展示 ls -S 输出文件按照文件大小排序 ls -t 输出文件按照修改时间排序 file 确定文件类型 file picture.jpg –&gt; picture.jpg: JPEG image data, JFIF standard 1.01 less 浏览文件 less somefile.txt 浏览指定文件 page up 向上翻滚一页 page down 向下翻滚一页 up arrow 向上翻滚一行 down arrow 向下翻滚一行 G 跳转到最后一行 1g/1G/g 跳转到第一行 /charaters 向前查找指定字符串 n 向前查找字符串，这个字符串是之前查找的 h 显示帮助屏幕 q 退出程序 more less is more(色即是空) less 相对与 more功能更加强大，more只支持分页浏览 一些常用目录 / 根目录，万物起源 /bin 包含系统启动和运行所必须的二进制程序 /boot linux 内核 /dev 一个包含设备文件的目录，linux中一切皆文件。 /etc 一些系统层面的配置文件 /etc/crontab 定义自动运行的任务 /etc/passwd 包含账户列表 /etc/hosts 主机配置信息 /etc/profile 系统环境变量 /etc/nginx/sites-available/default nginx配置文件位置，如果你用apt-get安装nginx的话 /home 通常，linux会在home目录下面为每一个用户创建一个目录，每个普通用户只能访问和操作自己用户目录下面的文件 /lib 系统运行所需要的核心类库 /media 挂载设备所在文件夹（一切皆文件） /root 管理员用户根目录 /sbin 包含系统二进制文件，通常为超级用户保留 /tmp 用于存储系统程序运行时的临时文件，某些系统配置会在系统启动时清空这个目录 /usr 包含普通用户所需要的程序和文件 /usr/bin 普通用户安装的文件 /usr/lib 普通用户共享的类库 /usr/local 通常用于安装从程序源码编译安装的软件 /var/log 系统日志所在文件 操作文件和目录 cp copy file and directory 复制文件和目录 mv move/rename files and directory 移动/重命名文件和目录 mkdir credit directories 创建目录 rm remove file and directory 移除文件和目录 ln create hard and symbolic links 创建硬连接和符号链接 通配符在介绍上面这些命令之前，我们首先一个使命令行无比强大的shell特性。因为shell命令需要频繁的使用文件名，所以shell提供了一组特殊字符用来快速指定某一组文件名，这些特殊字符就叫做通配符。 常见通配符 * 匹配任意多的字符（包括零个或者一个） ? 匹配任意一个字符（不包括零个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不再指定字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 [:alnum:] 匹配任意一个字母或者数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 常见通配符示例 * 全部文件 g* 所有以g开头的文件 b*.txt 以b开头中间有零个或者多个任意字符，并以.txt结尾的文件 Data??? 以Data开头，其后紧接着3个字符的文件 [abc]* 文件名以abc开头的文件 BACKUP.[0-9][0-9][0-9] 以BACKUP.开头并紧接着三个数字的文件 [[:upper:]]* 以大写字母开头的文件 *[[:lower:]123] 文件名以小写字母结尾或者是以1,2,3结尾 mkdir – 创建目录 mkdir directory 创建文件directory mkdir dir1 dir2 dir3 创建文件夹dir1,dir2,dir3 cp – 复制文件和目录 cp fromFileOrDir toFileOrDir 复制文件或文件夹fromFileOrDir到文件或文件夹toFileOrDir cp item1 item2 … toDirectory 复制多个文件到文件夹toDirectory 有用的选项 -a -archive 复制文件和目录，以及他们的属性，包括所有权和权限 -i -interactive 在重写已存在文件之前提示用户确认，如果不指定，cp命令会默认重写文件 -r -recursive 递归的复制目录以及目录中的内容，当复制目录的时候需要指定这个选项 -u -update 当复制文件时，只有在目标文件夹中不存在这个文件或者当前文件新于目标文件夹中的文件时才复制文件 -v -verbose 现实详细的命令操作信息 有用的示例 cp file1 file2 复制文件file1到file2,如果file2不存在那么创建，如果存在，那么覆盖 cp -i file2 file2 复制文件file1到file2,如果file2不存在那么创建，如果存在，那么提醒用户确认 cp file1 file2 dir 复制文件file1,file2到文件夹dir cp dir1/* dir2 复制文件夹1中的文件到dir2，dir2必须存在 cp -r dir1 dir2 递归复制文件夹dir1中的内容到dir2 mv 移动和重命名文件 mv fromFileOrDir toFileOrDir 移动（重命名）文件或文件夹fromFileOrDir到toFileOrDir mv item1 item2 … toDirectory 将一个或多个条目移动到另一个目录中 有用的选项 -i -interactive 在重写一个已经存在的文件之前，提示用户确认，如果不指定，mv命令会默认重写文件内容 -u -update 当把一个文件从一个目录移动到另一个目录时，只移动不存在的文件，或者较新的文件 -v -verbose 显示详细的信息 有用的示例 mv file1 file2 移动文件file1到file2,如果file2不存在直接复制，否则覆盖文件 mv -i file1 file2 移动文件file1到file2,如果file2不存在直接复制，否则提用户确认 mv file1 file2 dir 移动file1,file2到文件夹dir中，dir必须已经存在 mv dir1 dir2 如果dir2不存在，那么新建dir2,并且移动dir1中的内容到dir2,然后删除dir1。如果dir2存在，移动dir1中的内容到dir2. rm – 删除文件和目录 rm item1 item2 。。。 删除一个或多个文件或目录 选项 -i -interactive 在删除已经存在的文件前，提示用户确认，不然，此命令会默默删除文件 -r -recursive 递归的删除文件,用于删除目录 -f -force 不显示任何提示信息，同-interactive命令相反 -v -verbose 现实详细的操作信息 命令 rm file1 默默地删除文件file1 rm -i file1 删除文件之前，提醒用户确认 rm -r file1,dir1 删除文件file1,递归的删除文件夹dir1中的全部内容（文件以及dir） rm -rf file1,dir1 同上，如果file1或者dir1不存在，此命令仍然会执行 ln – 创建链接 ln file link 创建一个硬连接 ln -s file link 创建一个软链接 硬链接 硬连接和符号链接比起来，硬连接是最初Unix创建链接的方式，而符号链接更加现代，在默认情况下，每个文件有一个硬链接，这个硬链接给文件起名字。当我们创建了一个硬链接之后，就为文件创建了一个额外的目录条目。 一个硬链接不能关联它所在文件系统之外的其他文件，这是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件。 一个硬连接不能关联一个目录 一个硬链接和文件本身没有什么区别。不像符号链接,当你列出一个包含硬链接的目录内容时,你会看到没有特殊的链接指示说明。当一个硬链接被删除时,这个链接被删除,但是文件本身的内容仍然存在(这是说,它所占的磁盘空间不会被重新分配),直到所有关联这个文件的链接都删除掉。 *符号链接 一个符号链接指向一个文件,而且这个符号链接本身与其它的符号链接几乎没有区别。例如,如果你往一个符号链接里面写入东西,那么相关联的文件也被写入。然而,当你删除一个符号链接时,只有这个链接被删除,而不是文件自身。如果先于符号链接删除文件,这个链接仍然存在,但是不指向任何东西。在这种情况下,这个链接被称为坏链接。 使用命令 什么是命令 命令可以是一个可执行程序，例如任何在位于/usr/bin中的文件,java,python等 内建与shell自身的命令，或者说shell内部命令 shell脚本，其通常包含一组想关联的shell命令，共同完成某项功能 一个命令别名（网络上有一些很有意思的整蛊的文章，比如将ls命令作为rm -rf命令的别名，这样就不是列出一个文件夹的内容了，而是默默删除整个文件夹） 识别命令–type type command command 是需要识别的命令名称 icekredit@IceKredit ~ $ type type type is a shell builtin icekredit@IceKredit ~ $ type ls ls is aliased to `ls --color=auto&apos; icekredit@IceKredit ~ $ type cp cp is /bin/cp icekredit@IceKredit ~ $ type java java is /usr/local/java/jdk1.8.0_73/bin/java 显示一个可执行程序的位置 icekredit@IceKredit ~ $ which ls /bin/ls icekredit@IceKredit ~ $ which cp /bin/cp icekredit@IceKredit ~ $ which java /usr/local/java/jdk1.8.0_73/bin/java 此命令只对可执行程序有效 得到shell内部命令的帮助文档 icekredit@IceKredit ~ $ help cd cd: cd [-L|[-P [-e]] [-@]] [dir] Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option `cdable_vars&apos; is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed: resolve symbolic links in DIR after processing instances of `..&apos; -P use the physical directory structure without following symbolic links: resolve symbolic links in DIR before processing instances of `..&apos; -e if the -P option is supplied, and the current working directory cannot be determined successfully, exit with a non-zero status -@ on systems that support it, present a file with extended attributes as a directory containing the file attributes The default is to follow symbolic links, as if `-L&apos; were specified. `..&apos; is processed by removing the immediately previous pathname component back to a slash or the beginning of DIR. Exit Status: Returns 0 if the directory is changed, and if $PWD is set successfully when -P is used; non-zero otherwise. *出现在命令语法说明中的方括号表示可选的项目，一个竖杠字符表示互斥选项 显示程序手册 – –help icekredit@IceKredit ~ $ mkdir –help Usage: mkdir [OPTION]… DIRECTORY… Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z, --context=CTX set the SELinux security context of each created directory to CTX --help display this help and exit --version output version information and exit 显示程序手册 – man 大多数系统中，man使用less程序显示参考手册 显示适当的命令 – apropos 基于关键字进行匹配 icekredit@IceKredit ~ $ apropos diskarm_sync_file_range (2) - sync a file segment with diskbaobab (1) - A graphical tool to analyze disk usagecfdisk (8) - display or manipulate disk partition tablecgdisk (8) - Curses-based GUID partition table (GPT) manipulatorcryptdisks_start (8) - wrapper around cryptsetup that parses /etc/crypttab.cryptdisks_stop (8) - wrapper around cryptsetup that parses /etc/crypttab.df (1) - report file system disk space usage。。。 显示非常简洁的命令说明 – whatis icekredit@IceKredit ~ $ whatis ls ls (1) - list directory contents 显示程序info条目 – info 可以将多个命令放在一行，用多个分号分隔 为一个或多个命令创建别名 icekredit@IceKredit ~ $ alias foo=’cd /usr; ls; cd -‘ icekredit@IceKredit ~ $ type foo foo is aliased to `cd /usr; ls; cd -‘ 删除别名 icekredit@IceKredit ~ $ type foo foo is aliased to `cd /usr; ls; cd -‘ icekredit@IceKredit ~ $ unalias foo icekredit@IceKredit ~ $ type foo bash: type: foo: not found","tags":[{"name":"linux","slug":"linux","permalink":"http://nxllxn.github.io/tags/linux/"},{"name":"linux 命令行","slug":"linux-命令行","permalink":"http://nxllxn.github.io/tags/linux-命令行/"},{"name":"linux shell","slug":"linux-shell","permalink":"http://nxllxn.github.io/tags/linux-shell/"}]},{"title":"如何优雅地实现一个Java日期转换工具","date":"2017-05-27T07:26:45.951Z","path":"2017/05/27/java/java工具/DateTool/","text":"需求缘起 日常编程过程中或多或少需要用到日期转换相关的功能，比如常用格式相关的日期格式化为字符串或者是字符串转日期对象等，甚至有的时候需要一个兼容较多日期格式的字符串转日期方法，本文中我会实现一个基本满足上述功能的简单工具。 为什么要实现为一个工具而不是一个工具类呢。首先声明工具类和工具是有区别的，工具类是指XXXUtil这种命名的类，其内部通常包含一组功能相近或者相似的静态工具函数，注意了这里是静态工具函数。而工具是指以XXXTool这种命名的类，这种类通常是可实例化的，且内部有一组功能相近或者相似的实例方法。好吧，扯了这么多，其实大概意思就是我会用上一点点面向对象的设计思路。具体为什么要这样，看完本文你就会大概了解我的初衷的。 写在编码之前任何一份好的代码都必然是经过两次加工，第一次是在脑子里面，我不建议拿到需求就里面开始编码，首先你要把需求整个过一遍，在大脑里面有个大概的思路，此外，程序是写来处理异常情况的，为什么有“测试驱动编程”，就是我们先明确我们的代码需要处理的全部流程，需要的功能是什么，有哪些异常情况需要处理等等，做到这一步才能说我们理解了需求。 基本功能，基本的字符串转日期功能，基本的日期格式化为字符串功能，一个可以兼容多种日期格式的字符串转日期功能。 为了方便使用，可以为一些常用的格式转换提供默认实现 面向对象编程，提供一组接口，提供这个接口的不同实现，为什么不同？之后再告诉你！ 单例，我计划将这个工具设计为一个单例 线程安全，每次new一个日期转换工具类太麻烦而且浪费资源，我们会对日期格式化相关的对象做一个“缓存”。什么缓存，直接维护几个全局静态的实例不就好了吗？不！SimpleDateFormat不是线程安全的，在并发环境下这种实现就会出问题。那正确的姿势是什么呢？本文中我会使用ThreadLocal！ 单元测试，这里把单元测试列为设计实现的一部分，首先单元测试的重要性我们就不说了，主要是代码写完了，是骡子是马，总得遛一遛看一下对不对。 编码接口定义不多说了，直接上代码 public interface DateTool { /** * 日志TAG */ String TAG = &quot;DateTool&quot;; /** * 默认的日期格式 */ String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; /** * 默认月份格式 */ String DEFAULT_MONTH_FORMAT = &quot;yyyy-MM&quot;; /** * 默认年份格式 */ String DEFAULT_YEAR_FORMAT = &quot;yyyy&quot;; /** * 默认的时间格式 */ String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; /** * 默认的日期时间格式 */ String DEFAULT_DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; /** * 如果字符串长度为8位，且都是字符串，那么我们认为这是一个yyyyMMdd格式的日期 */ Pattern FULL_DATE_PATTERN = Pattern.compile(&quot;[0-9]{8}&quot;); //20120101 /** * 日期分隔符 */ String DATE_NOTIFIER_PATTERN_STR = &quot;[年月日\\\\-/.]+&quot;; /** * 时间分隔符 */ String TIME_NOTIFIER_PATTERN_STR = &quot;[时分秒点:]+&quot;; /** * 压缩的时间日期格式 */ String DATA_TIME_FORMAT = &quot;yyyyMMddHHmmss&quot;; /** * 压缩的日期格式 */ String DATA_FORMAT = &quot;yyyyMMdd&quot;; /** * 压缩的时间格式 */ String TIME_FORMAT = &quot;HHmmss&quot;; Pattern REG_PATTERN_FOR_DATE = Pattern.compile( &quot;((^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(10|12|0?[13578])([-/\\\\._])(3[01]|[12][0-9]|0?[1-9]).*$)&quot; + &quot;|(^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(11|0?[469])([-/\\\\._])(30|[12][0-9]|0?[1-9]).*$)&quot; + &quot;|(^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(0?2)([-/\\\\._])(2[0-8]|1[0-9]|0?[1-9]).*$)&quot; + &quot;|(^([2468][048]00)([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([3579][26]00)([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][0][48])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][0][48])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][2468][048])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][2468][048])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][13579][26])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][13579][26])([-/\\\\._])(0?2)([-/\\\\._])(29).*$))&quot;); /** * 使用指定格式化字符转换指定日期字符串 * * @param dateTimeStr 指定日期字符串 * @return 转换后得到的date */ Date parse(String dateTimeStr) throws Exception ; /** * 使用指定格式化字符转换指定日期字符串 * * @param dateString 指定日期字符串 * @param parseStr 指定格式化字符 * @return 转换后得到的date */ Date parse(String parseStr, String dateString) throws Exception ; /** * 按照指定字符串格式格式化指定日期 * @param pattern 字符串格式 * @param date 指定日期 * @return 格式化后的字符串 */ String format(String pattern, Date date) throws Exception ; /** * 使用默认日期格式转换指定日期字符换 * * @param dateString 指定日期字符串 * @return 转换后得到的date */ Date parseDate(String dateString) throws Exception ; /** * 使用默认日期格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatDate(Date date) throws Exception ; /** * 使用默认时间格式转换时间字符串 * * @param dateString 时间字符串 * @return 转换后得到的date */ Date parseTime(String dateString) throws Exception ; /** * 使用默认时间格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatTime(Date date) throws Exception ; /** * 使用默认格式转换指定日期时间字符串 * * @param dateString 指定日期时间字符串 * @return 转换后得到的date */ Date parseDateTime(String dateString) throws Exception ; /** * 使用默认日期时间格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatDateTime(Date date) throws Exception ; } 里面有比较详细的JavaDoc，我大概说一下 程序开始定义了一些常用的日期格式字符串常量 接下来是相关接口一共有9个接口： Date parse(String dateTimeStr);兼容多种日期格式的字符串转日期接口 Date parse(String parseStr, String dateString) ;使用指定格式化字符parseStr转换指定日期字符串dateString Date parseDate(String dateString) ; 使用默认日期格式转换指定日期字符换 Date parseTime(String dateString) ; 使用默认时间格式转换时间字符串 Date parseDateTime(String dateString) ; 使用默认日期时间格式转换指定日期时间字符串 String format(String pattern, Date date); 按照指定字符串格式格式化指定日期 String formatDate(Date date); 使用默认日期格式格式化date String formatTime(Date date) ; 使用默认时间格式格式化date String formatDateTime(Date date); 使用默认日期时间格式格式化date 一个字，清晰！明了！好了接下来就是具体实现了。 ThreadLocal实现时间转换格式“缓存”还是先上代码 public class BaseDateTool { /** * ThreadLocal 对象,用于存储当前线程中使用的日期格式化对象 */ private static final ThreadLocal convertDataFormatThreadLocal = new ThreadLocal(); /** * 获取或者实例化一个指定字符串格式对应的SimpleDateFormat对象 * @param pattern 格式化字符串 * @return 格式化字符串对应的SimpleDateFormat格式化对象 */ protected SimpleDateFormat getDateFormat(String pattern) throws Exception{ Map&lt;String,SimpleDateFormat&gt; map = (Map&lt;String, SimpleDateFormat&gt;) convertDataFormatThreadLocal.get(); if(map == null){ map = new HashMap&lt;&gt;(); map.put(pattern,new SimpleDateFormat(pattern)); convertDataFormatThreadLocal.set(map); } if(!map.containsKey(pattern)){ map.put(pattern,new SimpleDateFormat(pattern)); } return map.get(pattern); } } 这是具体实现类的一个基类，既然接口都抽出来了，把这一块功能抽离到一个基类里面好像也不过份吧。简单解释一下，首先声明了一个全局的静态的final的ThreadLocal对象，不用说了，我们用于日期转换格式化的SimpleDateFormat对象就会放到这里面。那么问题来了，怎么放呢，实际编码过程中，可能遇到各种类型的日期格式需要进行格式化或者转换。所以我们用一个Map来存储这些对象，key为实际的字符串格式，值为当前字符串格式对应的日期转换格式化对象，如果Map中已经存在了指定字符串格式的key，那么直接将这个key对应的对象返回，否则先new一个当前格式的对象，然后插入到Map中并返回。 具体实现老规矩，先上代码。 public class DateToolImpl extends BaseDateTool implements DateTool{ private DateToolImpl(){} private static class Holder{ private static final DateTool dateTool = new DateToolImpl(); } public static DateTool getSiingleInstance(){ return Holder.dateTool; } @Override public Date parse(String dateTimeStr) throws Exception { if (StringUtils.isEmpty(dateTimeStr)) { return null; } dateTimeStr = dateTimeStr.replaceAll(&quot;\\\\.\\\\d{3}&quot;, &quot;&quot;); //去除掉毫秒部分 String dateStr = null; String timeStr = null; String[] dateTimeStrParts = dateTimeStr.split(&quot;[ \\\\n]&quot;); for (String dateTimeStrPart : dateTimeStrParts) { if (REG_PATTERN_FOR_DATE.matcher(dateTimeStrPart).matches() || dateTimeStrPart.contains(&quot;年&quot;) || dateTimeStrPart.contains(&quot;月&quot;) || dateTimeStrPart.contains(&quot;日&quot;) || dateTimeStrPart.contains(&quot;-&quot;) || dateTimeStrPart.contains(&quot;/&quot;) || dateTimeStrPart.contains(&quot;.&quot;) || FULL_DATE_PATTERN.matcher(dateTimeStrPart).matches() || dateTimeStrPart.length() == 4) { dateStr = dateTimeStrPart; } else { timeStr = dateTimeStrPart; } } StringBuilder dateBuilder = new StringBuilder(); if (!StringUtils.isEmpty(dateStr)) { String[] dateParts = dateStr.split(DATE_NOTIFIER_PATTERN_STR); for (String datePart : dateParts) { if (datePart.length() == 1) { dateBuilder.append(&quot;0&quot;); } dateBuilder.append(datePart); } switch (dateBuilder.length()) { case 4: dateBuilder.append(&quot;0101&quot;); break; case 6: dateBuilder.append(&quot;01&quot;); break; } } StringBuilder timeBuilder = new StringBuilder(); if (!StringUtils.isEmpty(timeStr)) { String[] timeParts = timeStr.split(TIME_NOTIFIER_PATTERN_STR); for (String timePart : timeParts) { if (timePart.length() == 1) { timeBuilder.append(&quot;0&quot;); } timeBuilder.append(timePart); } switch (timeBuilder.length()) { case 2: timeBuilder.append(&quot;0000&quot;); break; case 4: timeBuilder.append(&quot;00&quot;); break; } } String formattedDateStr = dateBuilder.toString(); String formattedTimeStr = timeBuilder.toString(); if (StringUtils.isEmpty(formattedDateStr) &amp;&amp; StringUtils.isEmpty(formattedTimeStr)) { return null; } if (StringUtils.isEmpty(formattedDateStr)) { return parse(TIME_FORMAT,formattedTimeStr); } if (StringUtils.isEmpty(formattedTimeStr)) { return parse(DATA_FORMAT,formattedDateStr); } return parse(DATA_TIME_FORMAT,formattedDateStr + formattedTimeStr); } @Override public Date parse(String parseStr, String dateString) throws Exception { if(StringUtils.isEmpty(parseStr) || StringUtils.isEmpty(dateString)){ return null; } return getDateFormat(parseStr).parse(dateString); } @Override public String format(String pattern, Date date) throws Exception { if(StringUtils.isEmpty(pattern) || date == null){ return null; } return getDateFormat(pattern).format(date); } @Override public Date parseDate(String dateString) throws Exception { return parse(DEFAULT_DATE_FORMAT, dateString); } @Override public String formatDate(Date date) throws Exception { return format(DEFAULT_DATE_FORMAT, date); } @Override public Date parseTime(String dateString) throws Exception { return parse(DEFAULT_TIME_FORMAT, dateString); } @Override public String formatTime(Date date) throws Exception { return format(DEFAULT_TIME_FORMAT, date); } @Override public Date parseDateTime(String dateString) throws Exception { return parse(DEFAULT_DATETIME_FORMAT, dateString); } @Override public String formatDateTime(Date date) throws Exception { return format(DEFAULT_DATETIME_FORMAT, date); } } 具体实现细节我就不再多讲了，上面的每个实现都不是很复杂。 测试DateTool dateTool = DateToolImpl.getSingleInstance(); @Test @SuppressWarnings(&quot;unchecked&quot;) public void testIntelligentParse(){ assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;20120202&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-02&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-2&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年2月2日&quot;).toString()); assertEquals(&quot;Thu Feb 02 01:01:01 CST 2012&quot;,dateTool.parse(&quot;2012-02-02 01:01:01&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012/02/02&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-02&quot;).toString()); assertEquals(&quot;Thu Jan 01 20:12:02 CST 1970&quot;,dateTool.parse(&quot;201202&quot;).toString()); assertEquals(&quot;Sun Jan 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012&quot;).toString()); assertEquals(&quot;Sun Jan 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年02月&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012.02.01&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012.02&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:11:11 CST 1970&quot;,dateTool.parse(&quot;11:11:11&quot;).toString()); assertEquals(&quot;Thu Jan 01 01:01:01 CST 1970&quot;,dateTool.parse(&quot;1:1:1&quot;).toString()); assertEquals(&quot;Thu Jan 01 01:01:01 CST 1970&quot;,dateTool.parse(&quot;01:01:01&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:11:00 CST 1970&quot;,dateTool.parse(&quot;11:11&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:00:00 CST 1970&quot;,dateTool.parse(&quot;11&quot;).toString()); } 结果：上面的单元测试都可以通过 //测试多线程 public static void main(String[] args) { DateTool dateTool = DateToolImpl.getSingleInstance(); for (int index = 0;index &lt; 10;index ++){ new Thread(() -&gt; { String currentThreadName = Thread.currentThread().getName(); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;20120202&quot;)); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;11:11:11&quot;)); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;2012年02月02日 11:11:11&quot;)); }).start(); } } 结果： Thread-7 Thu Feb 02 00:00:00 CST 2012 Thread-8 Thu Feb 02 00:00:00 CST 2012 Thread-2 Thu Feb 02 00:00:00 CST 2012 Thread-7 Thu Jan 01 11:11:11 CST 1970 Thread-2 Thu Jan 01 11:11:11 CST 1970 Thread-3 Thu Feb 02 00:00:00 CST 2012 Thread-5 Thu Feb 02 00:00:00 CST 2012 Thread-3 Thu Jan 01 11:11:11 CST 1970 Thread-5 Thu Jan 01 11:11:11 CST 1970 Thread-6 Thu Feb 02 00:00:00 CST 2012 Thread-0 Thu Feb 02 00:00:00 CST 2012 Thread-3 Thu Feb 02 11:11:11 CST 2012 Thread-2 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Feb 02 00:00:00 CST 2012 Thread-4 Thu Feb 02 00:00:00 CST 2012 Thread-1 Thu Feb 02 00:00:00 CST 2012 Thread-0 Thu Jan 01 11:11:11 CST 1970 Thread-7 Thu Feb 02 11:11:11 CST 2012 Thread-1 Thu Jan 01 11:11:11 CST 1970 Thread-8 Thu Jan 01 11:11:11 CST 1970 Thread-0 Thu Feb 02 11:11:11 CST 2012 Thread-1 Thu Feb 02 11:11:11 CST 2012 Thread-8 Thu Feb 02 11:11:11 CST 2012 Thread-6 Thu Jan 01 11:11:11 CST 1970 Thread-5 Thu Feb 02 11:11:11 CST 2012 Thread-4 Thu Jan 01 11:11:11 CST 1970 Thread-6 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Jan 01 11:11:11 CST 1970 Thread-4 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Feb 02 11:11:11 CST 2012 为什么要定义接口我们为需要实现的功能定义了接口，并提供了一种实现。但是有些时候可能需要另一种实现。比如java8中提供了一组新的Date Api，比如日期格式化类DateTimeFormatter。如果我们希望利用Java8 Date api做一个新的实现，那么就可以在不改变原来代码的情况下直接扩展一个实现就好了。 结语只是一个小demo，代码写的不好，有什么问题恳请批评指正，感激涕零！此外，请轻喷！ 参考资料深入理解Java：SimpleDateFormat安全的时间格式化","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"日期转换工具","slug":"日期转换工具","permalink":"http://nxllxn.github.io/tags/日期转换工具/"},{"name":"日期格式化工具","slug":"日期格式化工具","permalink":"http://nxllxn.github.io/tags/日期格式化工具/"},{"name":"DateTool","slug":"DateTool","permalink":"http://nxllxn.github.io/tags/DateTool/"}]},{"title":"随笔","date":"2017-05-19T03:08:48.971Z","path":"2017/05/19/essay/essay/","text":"不如意事常八九，可与人言无二三。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://nxllxn.github.io/tags/随笔/"}]}]