[{"title":"What's QPS","date":"2017-08-21T08:26:31.922Z","path":"2017/08/21/java/performance/What's QPS/","text":"我听过，我知道;我看过，我记得;我做过，我懂了！ 需求缘起这一篇文章不是技术类的，可能并没有复杂的设计以及代码实现之类的，但是由于之前我自己老是搞不清楚QPS是什么怎么计算，并且在试图解决这个问题的时候遇到了一些新的问题，所以打算做个笔记，也把我兜圈子的过程给大家分享一下，如果刚好你也有这个问题并且我兜圈子的过程能给你一些提示，那再好不过。 PS：多图，流量党慎入，wifi党、土豪请随意！ 写在兜圈子之前为什么说是兜圈子呢？首先呢是因为我知道QPS是什么，但是对具体有那些因素可能成为系统中QPS的瓶颈又有些模棱两可;其次，影响系统QPS的因素有很多，而且究竟是哪一个因素起着决定性的作用又和具体情景之间有着很微妙的关系，如果不能静下心来集中精力思考，思路很容易断掉。所以如果你和我一样有这个问题，那就烦请带着你的脑子我们去兜一圈。 兜圈子什么是QPS每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 QPS，每秒查询速率，也可以说是系统的吞吐量。其实系统中很重要的一个性能指标，一般的业务系统还好，但是比如京东淘宝之内的电商系统，对于系统的吞吐量要求就比较高了。当然这些系统设计也更加复杂，今天我们只会举一些简单的例子来尽力搞明白QPS是什么，一个系统中影响QPS的因素有哪些，如果想要更深入的了解建议参考《亿级流量网站架构核心技术+跟开涛学搭建高可用高并发系统》。 举个栗子在正式分析具体哪些因素会成为系统QPS的瓶颈之前，我们先来看一个例子。具体场景呢相信大家都很熟悉，那就是餐厅。 让我们来梳理一下一家餐厅大致有哪些需要注意的点。为了更直观，我们从客人的角度来分析。客人走到餐厅，这时一个负责接待的服务员上来为他带路，带他到对应的座位上坐下，于此同时这位负责接待的服务员召唤来另一名服务员，这位服务员负责点餐，然后通知厨师，厨师根据点餐订单，用对应的烹饪工具烹饪出对应的菜品，服务员上菜，客人食用，最终客人完成餐后支付离开餐厅。 此外我们做如下约定 一个服务员必须服务于客人进入餐厅到离开餐厅的整个时间段 这家餐厅的河豚烹饪做的非常好，所以一度成为这家餐厅的招牌菜，几乎所有食客都是慕名而来。 由于客户数目会是QPS的一个体现，所以我们假设有源源不断稳定的客户 那么在对整个系统做了足够的简化之后，我们需要关注的点有： 客人 负责接待的服务员 负责客人点餐、厨师调派、进餐、客人支付整个流程的服务员 一般厨师 主厨 座位 烹饪工具 假设餐厅内的资源是无限制的那么，有无限多的服务员来服务于无限多的客户，将无限多的客户带到无限多的座位上，无限多的客户产生的无限多的点餐订单由无限多的厨师利用无限多的烹饪工具进行烹饪。皆大欢喜，普天同庆。 事实上不可能有无限多的服务员首先老板不会招募无限多的服务员的，哈哈，开个玩笑！真实情况是，服务员也会占据一些资源，比如立体空间，过道等等，无限多的服务员只会让餐厅乱成一锅粥。所以一般服务员的数目是确定的，这里我们暂且前记作numberOfWaiter（单位：人），我们可以把服务员想象成一个组或者一个队列。有新的客人来的时候，从这个组或者队列中借一个服务员，当为这个客人服务完毕，这个服务员被归还到这个组中。那么此时能够服务的客人的数目就是和客人用餐时间或者说服务员服务时间（暂且记为serviceTime，单位：小时）成反比了。也即服务客人数目=numberOfWaiter/serviceTime。 不可能有无限多的座位这个很好理解了，餐厅的空间是有限的嘛。假定餐厅中的座位数目为numberOfSeat（单位：个）。那么即使服务员能够服务的客人数目numberOfWaiter/serviceTime大于numberOfSeat，实际能够服务的客人数目也不会超过numberOfSeat。 不可能有无限多的厨师，或者说厨师不可能烹饪出无限多的菜肴道理也很简单，厨房空间有限。能够容纳的厨师很有限，即使一个厨师同时掌勺，控制多个烹饪工具，但是总归是有一个上限的。这里我们假设单位时间厨师可以服务的菜肴数目是numberOfCustomerCanFeed（为了方便，我们以人为计量单位，单位：人）。那么，即使服务员能够服务足够多的客人，且有足够的座位，实际能够服务的客人数目也不会超过numberOfCustomerCanFeed。 不可能有无限多的烹饪工具道理也很简单，厨房空间有限。这里我们假设单位时间烹饪工具最多能够产出的菜肴数目是numberOfCustomerCanApprove（同样，为了方便我们以人为计量单位，单位：人）;那么即使有足够多的客人需要服务，有足够多的位置可以坐，有足够多的厨师来掌勺，实际能够服务的客人数目也不会超过numberOfCustomerCanApprove。 只有一小部分或者一个主厨只有厨艺精湛的主厨才能恰当地烹饪河豚，做这个假设应该不过分。也就是说，即使大多数客人慕名而来，但是，客人能够点到的河豚是很有限的。这里我们假定能够提供的河豚烹饪量为numberOfCustomerStupid(为了方便，同样以人为计量单位，单位：人)。那么即使有足够多的客人需要服务，有足够多的位置可以坐，有足够多的厨师来掌勺，足够多的工具用于烹饪，实际能够服务的客人数目也不会超过numberOfCustomerStupid。 SO？天哪！我就吃个饭咋这么麻烦呢！其实上面的描述还算是简单的，实际上可能根据客户需要，不同情景下，更加复杂，究竟在某一种情景下，具体是哪一种因素是整个系统的瓶颈，还是需要消耗一些脑细胞进行分析的。比如某个菜肴制作过程十分复杂，那么numberOfCustomerCanFeed可能会急剧降低。如果用于客户用餐服务的服务员有几个请了假，或者每个客户的平均进餐时间变长了，numberOfWaiter/serviceTime也可能会受到很大影响。又比如某一台烹饪设施出了问题，某个主厨的妻子今天生小孩，都会对能够服务的客人数目造成影响。当然了这里说的是可能，毕竟最终的吞吐量是由最严重的瓶颈控制的。就像车道，吞吐量是由最窄的部分决定的，第二窄部分的波动可能并不会对整体吞吐量造成任何影响。 终于把这个栗子举完了，手真酸！不知道有没有讲明白！再举一个？算了还是不举了，不举了！ 从餐厅到业务系统扯了这么多，究竟跟具体的业务系统有什么关系呢？来来来，让我们先看张美图。 看完图片大家应该明明白了，其实上面这个例子中客人数目就是图中的请求线程数目;服务员数目numberOfWaiter就是我们图中的服务线程数目;服务员服务时间serviceTime就是图中的后台任务执行时间，包括IO和CPU总时间;厨师呢则可以看成是CPU，座位则可以看作是系统内存，当然了也可以把负责接待的服务员看作是带宽。此外烹饪用的工具可以看作是软件资源限制，比如数据库连接数目，Redis连接数目，RServer连接数目等。即使厨师操作很快，也不能跳过烹饪工具的限制，即使CPU计算能力很强，也不能无视第三方连接的限制。此外，能够恰当地烹饪河豚的主厨就是图中的第三方依赖，整个餐厅的运转速度都会受限于这个主厨烹饪河豚的能力，同理一个系统的QPS不可能高于其依赖的第三方系统的QPS，我们可以倒过来思考，如果当前系统的QPS更高，那么当前系统就会有不断的请求累积起来，系统最终就挂掉了。当然这只是一个思考的方式，实际上多余的请求会被放置到队列中，如果队列满了，根据具体的线程池策略，可能在得到处理机会之前已经被丢掉了。 实际的业务系统 首先是请求用户数目，之后的实战里面我们会用到Apache JMeter，其有一个线程组的概念，即在某一时间开启多少个线程，每一个线程循环调用指定接口，达到模拟的效果。这里再提一下，毕竟是模拟，而且是单机的，所以线程数目开太多的话最终结果和实际情况可能会有较大偏差，读者需要注意。 其次是服务线程数目，以SpringBoot内嵌的tomcat容器来说，其使用Java nio，实现高并发。其服务线程由线程池维护，默认核心线程数目是10个，线程池最多200个线程，注意，此数据不是文档给出，而是笔者在实际测试过程中根据JVisualVm工具观测得到的。什么意思呢，比如后台指定接口调用时间为1000ms，就是说一个线程一秒钟只能完成一次调用，那么此时系统的QPS最高只能到达200。之后会也有对应的测试案例供大家参考、验证。 后台任务执行时间，这里再次强调一下，这里执行时间时间包括CPU以及IO执行时间。也就是接口总执行时间 带宽，在每次调用传输的数据量较大时，此处很容易成为性能瓶颈，比如上传的测试数据是1M的Json字符串，服务器贷款是100mbps,那么实际的QPS可能最多只能达到100/8 = 12.5。 内存，这个和具体的业务代码有关了，如果业务代码执行期间需要大量的内存分配，此处可能成为QPS瓶颈，当然也可能是OutOfMemoryError，之后看能不能实际测试一下。 CPU，当然还是和具体业务代码有关，比如之前听过关于跑机器学习的机器QPS只能达到2。如果有比较复杂的算法，此处可能成为瓶颈，之后我会做个简单的测试，在一次接口调用中进行1000000次的浮点数乘法运算来展示具体的效果。 软件资源限制或者说第三方依赖QPS，比如数据库连接、数据库一次调用时间，Redis连接、Redis一次调用时间，RServer连接、RServer一次调用时间等。比如数据库连接100个，如果一次查询时间为200ms，那么系统吞吐量最大最大可达到500;如果一次查询时间为20ms，那么系统吞吐量最大可达到5000;这也可以解释为什么一般生产环境Mysql（Mysql一般不是），Redis，RServer等都部署到同一个节点上面，这样可以得到非常低的调用时间。之后我会设计一个模拟测试。展示第三方依赖QPS是如何成为当前业务系统QPS瓶颈的。 实战演练在实战之前，我们先做一下简单的介绍，简单的补一下课。那就是关于Java性能测试相关的工具。怎么说呢，如果某个业务系统运行十分缓慢，我们就可以利用这些工具快速的定位问题点，甚至熟练了之后我们在进行系统设计实现的时候就能够有效的避免这些问题。 深入理解JVM—-JDK的命令行工具 JMeter使用入门 主要是两个工具，第一个是Apache JMeter用于性能测试的，非常非常强大的一个工具，也提供了很多插件供大家选择。第二个工具是JVisualVm，用于实时监测当前计算机上面运行的进程，可以提供CPU，内存，线程，堆等的具体状态监控。也十分强大，对于应用程序性能分析十分方便。 最简单的接口调用代码1234567891011121314151617@RestController@RequestMapping(\"/qps\")public class QPSController &#123; private static final Logger logger = LoggerFactory.getLogger(QPSController.class); @PostMapping(\"/helloWithoutHesitation\") public String helloWithoutHesitation() throws Exception&#123; long startTimeInNano = System.nanoTime(); logger.info(\"线程名称：&#123;&#125;，线程ID：&#123;&#125;,请求时间：&#123;&#125;\", Thread.currentThread().getName(), Thread.currentThread().getId(), System.nanoTime() - startTimeInNano); return \"I am fine!Thank you!and you?\"; &#125;&#125; 可以看出，在这个接口中我们没有添加任何的业务逻辑。只是简单的打印了一条日志，并返回了一个结果。 测试JMeter &amp;&amp; JVisualVM上图为接口调用相关配置，非常简单，这里不做额外解释。 系统刚启动,应用程序线程，cpu，内存分配情况 可以看出，当JVM进程启动的时候，SpringBoot自带的tomcat容器初始化了一个大小为10的服务线程线程池。这个可以理解为为线程池核心线程数目。当有更快速的请求被提交时，线程池会进一步扩充，根据测试结果，线程池默认的最大大小为200,从之后的测试用例中也可以看出来。当客户端请求速度进一步提升时，线程池已经无法进一步增长了，这时“多余的”请求会被放置到队列中，如果请求速度进一步增加，那么当队列满了之后会根据具体的线程池策略进行处理,比如直接丢弃当前请求等。更多关于tomcat线程池相关的读者可以自行百度。下面是两个相关的资料。Tomcat线程池策略Tomcat的maxThreads、acceptCount（最大线程数、最大排队数） 线程组只有一个线程 做一下简单的分析：图1展示了JMeter线程组设置，可以看出我们只启动了一个线程，这个线程会持续运行60秒钟。图2展示了程序运行期间CPU消耗情况以及内存分配情况。图3展示了程序运行期间，当前应用程序内线程运行情况，可以看出，来自客户端的请求分布在了这10个核心线程上。图4展示了JMeter测试结果，可以看出整个测试期间一共发送了16070个请求，系统当前的吞吐量为267.8/s 线程组有10个线程做一下简单的分析：图1展示了JMeter线程组设置，可以看出我们计划启动10个线程，刚开始立即启动两个，之后每一秒启动两个线程，启动完成后整个线程组持续运行60秒，最后每一秒关闭两个线程。整个测试计划会运行68秒。图2展示了程序运行期间CPU消耗情况以及内存分配情况。图3展示了程序运行期间，当前应用程序内线程运行情况，可以看出，来自客户端的请求分布在了这10个核心线程上。（其实图截的有点问题，其实服务线程会比请求线程数目稍微大一些，实际测试时图片下方还有一个新建的线程11）图4展示了JMeter测试结果，可以看到当前测得系统吞吐量有了很大的提升。那么为什么要更高呢，那就是因为单个线程虽说持续运行，但是他的请求提交能力是有限的，不足以产生足够的请求速度。 线程组有100个线程做一下简单的分析：图1展示了JMeter线程组设置，可以看出我们计划启动100个线程。具体设置参考第二步的设置，此处不再赘述。图2展示了程序运行期间CPU消耗情况以及内存分配情况。从右下角也可以大致看出，tomcat容器内创建了更多的服务线程，100多一点的样子。图3展示了程序运行期间，当前应用程序内线程运行情况。可以看出请求分布在了这100个线程上（其实图截的有点问题，其实服务线程会比请求线程数目稍微大一些，实际测试时应该有101个服务线程）图4展示了JMeter测试结果，可以看出相较于第二步，系统吞吐量又有了一些提升。 线程组有200个线程做一下简单分析：图1展示了JMeter线程组设置，可以看出我们计划启动200个线程。具体设置参考第二步的设置，此处不再赘述。图2展示了程序运行期间CPU消耗情况以及内存分配情况。图3展示了程序运行期间，当前应用程序内线程运行情况。可以看出系统一共创建了200个线程（高亮的那一行线程名http-nio-8080-200）。图4展示了JMeter测试结果，可以看出系统吞吐量有了很大的提升。 线程组有500个线程做一下简单分析：图1展示了JMeter线程组设置，可以看出我们计划启动500个线程。具体设置参考第二步的设置，此处不再赘述。图2展示了程序运行期间CPU消耗情况以及内存分配情况。图3展示了程序运行期间，当前应用程序内线程运行情况。可以看出系统还是一共创建了200个线程（高亮的那一行线程名http-nio-8080-200）。这也说明tomcat默认的maxThreads为200图4展示了程序运行结果，可以看出系统的吞吐量反而降低了。此处需要注意一下，我觉得此处吞吐量降低可能是因为测试工具里面开的线程数目太多，所以由于测试工具所在计算机忙着调度去了，没有全心全意的专注于发请求。其实后台并没有达到QPS极限，毕竟第四步就已经证明系统最大QPS至少比第五步的高，就是说系统处理能力是没有消耗完的。 总结上面几个测试中我们大致过了一下：1）应用容器请求处理的模块的池化策略。2)JMeter,JVisualVM工具的使用 测试较高的请求处理时间此测试中我们会控制请求处理时间，通过Thread.sleep()来模拟。我们会让线程休眠一秒钟，来看测试结果。 具体代码1234567891011121314151617181920@RestController@RequestMapping(\"/qps\")public class QPSController &#123; private static final Logger logger = LoggerFactory.getLogger(QPSController.class); @PostMapping(\"/helloWithHesitation1000Millis\") public String helloWithHesitation1000Millis() throws Exception&#123; long startTimeInNano = System.nanoTime(); //模拟比较长的操作，比如io，复杂的数据计算等 Thread.sleep(1000); logger.info(\"线程名称：&#123;&#125;，线程ID：&#123;&#125;,请求时间：&#123;&#125;\", Thread.currentThread().getName(), Thread.currentThread().getId(), System.nanoTime() - startTimeInNano); return \"I am fine!Thank you!and you?\"; &#125;&#125; 测试JMeter &amp;&amp; JVisualVM上图为接口调用相关配置，非常简单，这里不做额外解释。 线程组有100个线程做一下简单分析：图1展示了JMeter线程组设置，可以看出我们计划启动100个线程。图2展示了程序运行期间CPU消耗情况以及内存分配情况。图3展示了程序运行期间，当前应用程序内线程运行情况。看出为了服务这100个客户端提交的请求，tomcat容器一共创建了了101个线程。图4展示了JMeter测试结果，可以看出系统整体的吞吐量只有83。就是说101个线程在每个接口处理时间大概为1秒或者说单位时间的情况下能够产出的QPS是小于服务线程总数目的。这也验证了之前提到的，当加上了池化策略时，系统的QPS和每个请求处理时间是成反比的。 线程组有200个线程做一下简单分析：此测试同上一个测试用例大致相同。结果也是一致的。再一次验证，当加上了池化策略时，系统的QPS和每个请求处理时间是成反比的。 测试复杂的CPU计算此测试中我们在请求接口中执行1000000次浮点数计算，来模拟复杂的CPU计算。 具体代码123456789101112131415161718192021222324@RestController@RequestMapping(\"/qps\")public class QPSController &#123; private static final Logger logger = LoggerFactory.getLogger(QPSController.class); @PostMapping(\"/helloWithComplicateCalculation\") public String helloWithComplicateCalculation() throws Exception&#123; long startTimeInNano = System.nanoTime(); //模拟比较复杂的cpu计算 double neverUsedValue = 0D; for (int index = 0;index &lt; 1000000;index ++)&#123; neverUsedValue *= index; &#125; logger.info(\"result:\" + neverUsedValue); logger.info(\"线程名称：&#123;&#125;，线程ID：&#123;&#125;,请求时间：&#123;&#125;\", Thread.currentThread().getName(), Thread.currentThread().getId(), System.nanoTime() - startTimeInNano); return \"I am fine!Thank you!and you?\"; &#125;&#125; 测试JMeter &amp;&amp; JVisualVM上图为接口调用相关配置，非常简单，这里不做额外解释。 线程组有1个线程 线程组有10个线程 线程组有20个线程 线程组有50个线程 线程组有100个线程 线程组有200个线程 线程组有500个线程 上面几组测试用例分别展示了客户端请求线程数目为1,10,20,50,100,200,500时调用包含复杂CPU计算的接口时系统可能达到的吞吐量结果。可以看出当请求增加，很快就能够消耗掉CPU全部的计算能力，此时CPU的计算能力成为了系统QPS的一个瓶颈。 测试第三方依赖QPS此测试中我们在请求接口中会模拟一个第三方依赖调用。同样也是利用线程池。现今许多地方都会有池化技术，比如数据库连接池，DBCP，Druid等，Redis连接池，Jedis等，RServer连接池，如RUtils内部实现的RConnectionPool。我们通过控制连接池中线程执行时间来控制第三方依赖QPS。比如大小为10的固定线程池，当一次调用时间为200ms，这个连接池的QPS为10 / （200D / 1000） = 50。当一次调用时间为100ms，这个连接池的QPS为10 / （100D / 1000） = 100。 具体代码123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(\"/qps\")public class QPSController &#123; private static final Logger logger = LoggerFactory.getLogger(QPSController.class); private static final ExecutorService thirdDependenciesPool = Executors.newFixedThreadPool(10); private Callable&lt;String&gt; thirdDependencyCallable = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; try &#123; //Thread.sleep(100); Thread.sleep(200); &#125;catch (InterruptedException e)&#123; logger.error(\"线程中断！\" ); &#125; return \"I am fine!Thank you!and you?\"; &#125; &#125;; @PostMapping(\"/helloWithThirdDependenciesLimit\") public String helloWithThirdDependenciesLimit() throws Exception&#123; long startTimeInNano = System.nanoTime(); String responseStr = thirdDependenciesPool.submit(thirdDependencyCallable).get(); logger.info(\"线程名称：&#123;&#125;，线程ID：&#123;&#125;,请求时间：&#123;&#125;\", Thread.currentThread().getName(), Thread.currentThread().getId(), System.nanoTime() - startTimeInNano); return responseStr; &#125;&#125; 上面已经对思路做了具体阐述，代码也相对比较简单，此处不再赘述。 测试JMeter &amp;&amp; JVisualVM此处我们就不提供复杂的测试用例了，为了做区分，这里统一使用JMeter开启200个线程进行测试 一次调用时间为200ms 一次调用时间为100ms 可以看出，第一个测试用例QPS为49,稍微低于模拟的第三方依赖QPS 50,第二个测试用例QPS为91,稍微低于模拟的第三方依赖QPS 100。 总结从上面各个测试用例可以大致看出之前提到的这些因素具体是如何影响系统最终的吞吐量的。到了具体分析系统QPS时，只需要对这些关键因素进行分析，再结合具体的系统部署场景便可以快速的定位到系统QPS瓶颈所在。","tags":[{"name":"Java","slug":"Java","permalink":"http://nxllxn.github.io/tags/Java/"},{"name":"QPS","slug":"QPS","permalink":"http://nxllxn.github.io/tags/QPS/"},{"name":"JMeter","slug":"JMeter","permalink":"http://nxllxn.github.io/tags/JMeter/"},{"name":"JVisualVm","slug":"JVisualVm","permalink":"http://nxllxn.github.io/tags/JVisualVm/"}]},{"title":"AOP+ExceptionHandler+ControllerAdvice实现全局异常处理与日志打印","date":"2017-07-30T07:47:48.697Z","path":"2017/07/30/java/aop/LogAspectj/","text":"需求缘起在一般的业务系统开发过程中异常处理和日志打印都是很常见也很必要的部分。 首先是异常处理，你可以通过在代码中加上无数的try-catch代码块儿来完成这件事情，但是这样写出的代码非常不美观，而且大多数都是重复性劳动。举个例子，比如接口接收参数处理这件事情，假设你需要一个long类型的id来完成一次以id为准的查询，同时我们也假设这个调用接口的客户端非常“不负责任”，在调用过程中任何可能的值都可能被传递过来，比如根本就没有传指定字段，空字符串，null,一段非数字的文本（“张三123”）,一个负数等等。当你想要将这个入参字符串转换为一个数值id时，可能发生各种异常，比如空指针啊，数字格式化异常等等。这时肯定不能直接让程序崩溃掉，然后给前端一个500吧？这时不可避免的就需要进行异常处理，你可能会说，“很简单啊，我加一个try-catch块就好了”，对，你这的确可以解决问题，但是新的问题来了，如果有10个20个甚至100个接口，每个接口你都做一遍这种重复性的劳动，岂不是很sb。所以笔者还是推荐使用全局的异常处理机制，在不影响系统功能或者说系统流程执行的情况下，尽量将捕获到的异常向外层调用者抛出，然后在最外层的ExceptionHandler中进行处理。 其次我们说一下关于日志打印，你可能又会说了，程序写到那里，如果需要打印日志直接打印就好了。那么我想申明我的几个观点：1）你有必要在整个执行流程里面加上这些日志打印的逻辑吗，这么做和单步调试有什么分别，为什么要用日志来做调试的工作呢，感觉和用System.out.println()的如出一辙。2）如果发生了系统故障，凭借输入，输出，异常堆栈应该完全可以定位到异常代码的位置了，如果此时还不能定位，只能说明代码设计有问题。3）日志从接口调用的输入，异常处理（不是必要的），输出最好能够在一起被打印出来，这很好理解了，因为业务系统运行起来基本是多线程的，如果输入输出打印不同步，日志阅读起来将非常困难。此外，日志是为了帮助程序员在出异常的时候能够快速定位到异常代码的位置。换句话说这些东西并不能看作业务代码的一部分，好的设计应该尽可能减少这些“不相关的代码”对真正的业务代码的侵入性。所以我们也希望实现全局的日志打印。 写在编码之前前面详细阐述了需求，现在简单描述一下实现思路： 全局异常处理：异常抛出+ControllerAdvice+ExceptionHandler 全局日志打印，分两种情况： 存在异常，直接在ExceptionHandler注解标注的方法中进行日志打印，包括请求url，参数，对应的异常情况下的响应。 不存在异常，直接在Spring Aop中进行日志打印，spring around注解标注的方法中可以拿到controller中接口返回的响应，先打印日志，再返回结果。 注意点实际的设计可能与上述设计有一些出入，主要原因如下： 我们定义的切面在Controller的接口上面，但是利用@RequestBody注解（对应Post方法）和@RequestParam注解（对应Get方法）进行参数绑定的过程发生在aop之前。而参数绑定过程中如果Post请求请求体body为空，将直接抛出HttpMessageNotReadableException异常，如果Get请求参数缺失将直接抛出MissingServletRequestParameterException异常。如果抛出异常，请求实体HttpServletRequest以及对应的Exception对象将直接交付给由ExceptionHandler注解的方法进行处理，而不会再进入aop中，所以这些请求的日志打不出来。那么这部分“遗漏的请求”必须在由ExceptionHandler注解的方法中进行日志打印。 在实际编码过程中我们也遇到另一个问题，就是HttpServletRequest对象在ExceptionHandler中无法取出参数，InputStream为空，调用getReader抛出流已经被打开的异常。但是在aop中可以通过@Around注解标记的方法的入参ProceedingJoinPoint.getArgs获取到。所以我们决大多数日志都在aop中进行打印。 会不会有遗漏参数的情况呢，其实是有的，HttpMessageNotReadableException对应Post请求请求体body为空，这是没有参数可取，也就没有遗漏一说。MissingServletRequestParameterException对应Get请求参数缺失。这时，我们还需要利用HttpServletRequest.getQueryString将请求参数打印出来。 代码实现AOP日志打印12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Aspect //定义一个切面@Configurationpublic class LogAspect &#123; private static final String TAG = \"LogAspect\"; // 定义切点Pointcut @Pointcut(\"execution(* com.nxllxn.controller.*Controller.*(..))\") public void executeService() &#123; &#125; @Around(\"executeService()\") public Object executeService(ProceedingJoinPoint pjp) throws Throwable &#123; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; HttpServletRequest request = sra.getRequest(); String url = request.getRequestURL().toString(); String method = request.getMethod(); String requestParamStr = null; if (method.equalsIgnoreCase(\"GET\")) &#123; requestParamStr = request.getQueryString(); &#125; else if (method.equalsIgnoreCase(\"POST\")) &#123; requestParamStr = Arrays.toString(pjp.getArgs()); &#125; // result的值就是被拦截方法的返回值 Object result; try &#123; result = pjp.proceed(); &#125; catch (Exception ex) &#123; //如果发生异常，那么将其转换为用户友好的接口调用返回信息 String code = getCodeByException(ex); String msd = getMsgByException(ex); JSONObject resultJsonObj = new JSONObject(); resultJsonObj.put(\"code\", code); resultJsonObj.put(\"msg\", msg); Log.i(TAG, String.format(\"[%s] [%s] [%s] [%s]\", method.toUpperCase(), url, requestParamStr, resultJsonObj)); return resultJsonObj.toJSONString(); &#125; Log.i(TAG, String.format(\"[%s] [%s] [%s] [%s]\", method.toUpperCase(), url, requestParamStr, result)); return result; &#125;&#125; 代码很简单，就几个关键点提一下： 首先我们定义了PointCut。就是当前切面在controller包下面的所有Controller中所有接口之前执行 我们从@Around注解标记的方法的入参ProceedingJoinPoint对象中取出了请求对象HttpServletRequest 从HttpServletRequest中取出请求方法，url 如果是Get请求，那么用request.getQueryString()取出参素 如果是Post请求，利用ProceedingJoinPoint.getArgs()取出参数 ProceedingJoinPoint.proceed()方法执行时会具体调用我们要调用的接口并得到返回值result。 接下来对异常进行处理，按照规范为异常定义统一的异常码，以及异常提示语句。 打印日志，格式为[请求方法] [请求URL] [请求参数] [返回结果] ExceptionHandler异常处理1234567891011121314151617181920212223242526272829303132@ControllerAdvicepublic class ExceptionHandler&#123; private static final String TAG = \"ExceptionHandler\"; @org.springframework.web.bind.annotation.ExceptionHandler public String exceptionHandler(HttpServletRequest request,Exception e) throws IOException &#123; String url = request.getRequestURL().toString(); String method = request.getMethod(); //为什么这里还需要处理呢，那是因为HttpMessageNotReadableException MissingServletRequestParameterException //这两个异常发生在aop进入切面之前的参数绑定阶段（spring自动完成的），如果参数缺失，将无法在aop（LogAspect）中打印出日志 //为什么这里只处理get的情况呢，因为 //如果是Post请求，有参数的话，即使为null也会进入aop（LogAspect）。如果完全没有参数（即传递的是空字符串，那么requestParamStr就是空字符串，没有处理一说） //如果是Get请求，不缺少单数，进入aop（LogAspect）打印日志，如果缺少参数在此处打印日志 String requestParamStr = null; if (method.equalsIgnoreCase(\"GET\")) &#123; requestParamStr = request.getQueryString(); &#125; String code = getCodeByException(ex); String msd = getMsgByException(ex); JSONObject resultJsonObj = new JSONObject(); resultJsonObj.put(\"code\", code); resultJsonObj.put(\"msg\", msg); Log.i(TAG, String.format(\"[%s] [%s] [%s] [%s]\", method.toUpperCase(), url, requestParamStr, resultJsonObj.toJSONString())); return resultJsonObj.toJSONString(); &#125;&#125; 代码描述： 首先用ControllerAdvice注解注解用于全局异常处理的类 其次用ExceptionHandler注解注解用于全局异常处理的方法,此方法拥有签名String exceptionHandler(HttpServletRequest,Exception) 如果是GET请求，需要做一点额外处理，就是取出参数，Post不用，因为这种情况下肯定是HttpMessageNotReadableException异常，换句话说，请求参数为空 接下来对异常进行处理，按照规范为异常定义统一的异常码，以及异常提示语句。 打印日志，格式为[请求方法] [请求URL] [请求参数] [返回结果] 结束语至此我们的全局异常处理以及全局日志打印就实现完成了。","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"AOP","slug":"AOP","permalink":"http://nxllxn.github.io/tags/AOP/"},{"name":"AspectJ","slug":"AspectJ","permalink":"http://nxllxn.github.io/tags/AspectJ/"},{"name":"ExceptionHandler","slug":"ExceptionHandler","permalink":"http://nxllxn.github.io/tags/ExceptionHandler/"},{"name":"ControllerAdvice","slug":"ControllerAdvice","permalink":"http://nxllxn.github.io/tags/ControllerAdvice/"},{"name":"全局异常处理","slug":"全局异常处理","permalink":"http://nxllxn.github.io/tags/全局异常处理/"},{"name":"日志","slug":"日志","permalink":"http://nxllxn.github.io/tags/日志/"}]},{"title":"Java虚拟机--运行时数据区","date":"2017-07-23T13:52:10.439Z","path":"2017/07/23/java/Java虚拟机/JavaMemoryDistribution/","text":"Java内存区域 Java与C++之间有一堵由内存分配和垃圾收集机制所围成的“高墙”，墙外面的人想进去，墙里面的人想出来 概述如果你是一名c或者c++程序员，不可否认你对于每一个可用的内存单元都有完全的控制，但是你也不得不承认为了保证没有内存泄漏，你不得不时刻战战兢兢，调动每一个脑细胞时刻留意malloc，alloc，以及new等操作新分配的内存区域。如果你是一名java程序员，恭喜你，不戴这王冠，也就无需承其重。不过即使是美好的东西，如果不能掌控，也可能后患无穷。你可能觉得我危言耸听，等你真正遇到java的百慕大三角你便会明白以为你明白了和你明白了绝大多数时候都是不能划等号的。本节会介绍Java运行时数据区，本文参考自《深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）》第二章，并会对关键知识点做梳理，同时也提供了详细的测试实例。测试源码托管至github。 运行时数据区域Java虚拟机在执行Java程序时会将它所管理的内存划分为多个不同的数据区域，每个数据区域有着不同的职责，以及特定的生命周期。根据《Java虚拟机规范（java se 7版）》，Java虚拟机所管理的内存将会包括如下几个数据区域，见下图。 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，注意这里说的是一块，之前理解的程序计数器就是一个单独的内存单元，还是有点想当然了，具体为什么是一块内存区域，请继续往下看。 程序计数器是作为当前线程所执行的字节码的行号指示器。这个很好理解了，程序计数器保存了当前执行指令的地址。当当前指令执行完成，根据具体的顺序，分支，循环，异常处理，线程恢复等控制程序计数器的值来决定下一条需要执行的指令地址。Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的（不用多说，现在的计算机基本都是分时系统），但是需要注意的一点是，多个线程会交替执行，这中间便存在线程切换，为了使线程切换后能够恢复到正确的执行位置每条线程都需要一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。我们称这类内存区域为“线程私有”的内存。 Java虚拟机栈虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧。如果不清楚这一点，可以网上查阅关于方法栈相关的资料，不过LZ坚持认为最好的方式是使用c或者c++这类语言，实现一个简单的函数调用，然后以debug的模式逐步跟踪方法栈从建立到销毁,栈上内存分配的全过程。当你知道方法参数如何传递，返回地址如何存放，局部变量内存单元如何分配，之后的知识就很容易理解了。 万变不离其宗，Java的方法栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行再到返回，就对应着一个栈帧在虚拟机栈中入栈到出栈的全过程。 经常有程序员按照自身的关注点，以对象内存分配关系为区分，将Java内存区域分为堆内存和栈内存，不过这么分太过笼统，Java内存模型远比这复杂。 通常程序员所说的栈就是指虚拟机栈，或者说是虚拟机栈中的局部变量表部分。局部变量表存储了编译期可知的各种基本数据类型（boolean，int，float，long，double）、对象引用以及返回地址。long和double占据两个内存单元或者说slot。其他数据类型都只占据一个slot。局部变量表所需的空间在编译期间就已经确定，并且在方法运行期间都不会发生改变。 此外，这个内存区域定义了两种形式的异常： 如果线程请求的栈深度大于虚拟机所允许的深度（此处需要注意一下，允许的栈深度通常不固定，根据LZ理解，栈深度或者说栈的数目=可用栈空间/栈帧的大小，也就是说总内存一定的情况下，分配的局部变量较少通常能够保证更多的方法栈的建立），将抛出StackOverFlowError异常 如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以扩展），扩展过程中无法申请到足够的内存，将抛出OutOfMemoryError异常 关于Java虚拟机栈更详细的知识请参考Java虚拟机栈 本地方法栈（Native Method Stack）本地方法栈与虚拟机栈作用非常相似，他们之间的区别只不过是虚拟机栈为虚拟机执行Java方法（也就是用户程序或者说用户程序字节码）服务，而本地方法栈则为虚拟机使用到的native方法服务。 Java堆（Java Heap）对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有对象共享的一块内存区域，在虚拟机启动时创建。此内存的唯一目的就是存放对象的引用，几乎所有的对象实例都在这里分配内存。 Java堆也是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”，从内存回收角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为新生代和老年代，再细致一点的有Eden空间，FromSurvivor空间，ToSurvivor空间。 方法区（Method Area）方法区与java堆一样，由各个线程共享，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。 运行时常量池（Runtime Constant Pool）运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息，还有一项信息是常量池。用于存放编译期生成的各种字面量和符号引用。既然运行时常量区是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时便会抛出OutOfMemoryError。常见的字符串的拼接会导致常量区存储一个新的字符串常量，如果在一个循环中不停的进行字符串的拼接将会导致OutOfMemoryError. 直接内存（Direct Memory）直接内存不是Java虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存被频繁使用。比如Java nio（new IO）中引入了一种基于通道与缓冲区的IO方式，它使用Native函数库直接分配堆外内存，然后通过一个存贮在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样可以在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 HotSpot虚拟机对象探秘对象创建虚拟机遇到一条New指令时，首先检查这个指令的参数是否在常量池中能够定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，那必须先进行类的加载，之后指定章节会详细讨论类的加载。如果类加载完成。接下来虚拟机将为新生对象分配内存，对象所需的大小在编译期已经确定，为对象分配空间等同于将一块确定大小的内存从Java堆中划分出来。假设Java堆是绝对规整的，所有用过的内存都放在一边，空闲的放在另外一边，中间放着一个指针作为分界点的指示器。那分配内存就好比将指针朝着空闲空间那边移动一段与对象大小相等的距离。这种方式称为指针碰撞。如果Java堆不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机就只能维护一个列表，标识出内存中有哪些内存块是可用的。在分配的时候找到一块足够大的空间划分给对象（此处找一块空闲空间甚至可以单独拆出来写一个小节，为什么这么说呢，我们选一个最小的能满足需求的内存块进行分分配的话，剩余的空间会很小，这样容易产生内存碎片，如果我们选一个较大的空间来分配，虽然可以保证减少内存碎片，但是内存空间会越来越零散）。这种分配方式称之为“空闲列表”。具体选择哪种方式视java堆是否规整而定，而Java堆是否规整通常取决于对应的垃圾收集算法是否带有压缩整理的功能。因此在使用Serial，ParNew等带Compact过程的收集器时，系统采用的是指针碰撞，而使用CMS这种基于Mark-sweep算法的收集器通常采用空闲列表。 此外，由于堆内存相当于临界资源，多个线程并发访问进行内存分配，所以不可避免的需要线程同步机制，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种实现方式是，把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存。称为本地线程分配缓冲，哪个线程需要分配内存就在自己的缓冲区上分配，只有缓冲区使用完需要重新分配新的缓冲区时才需要同步锁定。 内存分配完成后，虚拟机将分配到的内存空间除了对象头都初始化为零值（突然想到c语言中将内存空间初始化为0xcc0xcc0xcc0xcc0xcc0xcc，最终显示为烫烫，哈哈）。 接下来，虚拟机要对这个对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，GC分代年龄等。 这时在虚拟机看来一个对象已经生成，但从Java程序的角度来看，对象创建才刚刚开始。init方法还没有执行。所有的字段都还为零，所以一般来说，执行new指令之后，会接着执行init方法，对应的是一条invokeSpecial指令，把对象按照程序员的意愿进行初始化。 对象的内存布局在HotSpot虚拟机中，对象在内存中的布局可以分为3块区域：对象头（Header），实例数据（Instance Data）和对齐填充（Padding）。 对象头第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程Id，偏向时间戳等。这部分数据通常与对象具体内容无关，所以为了节省额外成本， 一般使用32位（32位机）或者64位（64位机）来存储，32位或者64位中不同区段分别代表着上述不同的子模块。 对象头第二部分是类型指针，即指向它的类元数据的指针，虚拟机通过这个指针来确定当前对象是哪个类的实例。 接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。包括从付父类继承下来的以及子类中新定义的。 最后一部分对齐填充并不是必然存在的，由于HotSpotVm的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以如果实例数据部分末尾不足8字节需要进行填充来补全。 对象的访问定位我们的程序需要通过栈上的对象引用来操作堆上的具体对象。通常有两种实现方式： 使用句柄访问，是指首先在Java堆中划分一块内存作为句柄池。对象引用中存储的就是句柄地址，而具体的句柄中包含了对象实例数据与类型数据各自具体的地址信息。 使用直接指针访问，java栈中的引用存储的就是对象的地址，对象实例中保存指向当前类型数据的地址 二者的优劣 使用句柄访问好处就是，reference中存储的是稳定的句柄地址，在对象被移动时（比如垃圾回收的compact）只会改变句柄中的实例数据指针，而reference本身无需修改 使用直接指针访问的好处就是，速度更快，因为它节省了一次指针定位的开销，由于对象在Java中的访问十分频繁。因此此类开销积少成多后也是一项可观的执行成本。 实战：OutOfMemoryError本部分主要有两个目的： 通过代码验证Java虚拟机规范中描述的各个运行时区域的内容 希望读者在工作中遇到实际的内存溢出异常时能够根据异常信息快速判断哪个区域的内存溢出。知道为什么导致内存溢出，以及应该如何处理 注意：代码的开头都有设置虚拟机启动参数，读者请按照示例进行设置，因为这些参数将直接控制示例程序的行为 Intellij IDEA JVM参数设置参考资料：Intellij IDEA JVM参数设置 Java堆溢出Java堆用于存储对象实例，如果不断的创建对象，并且保证GCRoots到对象之间有可达路径（利用List进行对象引用的存储，List类的栈对象引用指向List堆实例，List堆实例中的每个对象引用再指向具体的堆上的对象实例）来避免垃圾回收机制来回收这些对象，那么当对象实例占据的存储空间超过最大堆容量之后就会产生堆内存溢出。 设置参数限制Java堆大小为20Mb，不可扩展（将堆的最小值-Xms参数与最大参数-Xmx设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前内存堆转储快照以便事后分析。 1234567891011121314151617181920/** * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -verbose:gc -XX:+PrintGCDetails -XX:SurvivorRatio=8 */public class HeapOutOfMemory &#123; public static class SomeClass&#123; public SomeClass() &#123; &#125; &#125; public static void main(String[] args) &#123; List&lt;SomeClass&gt; someClasses = new ArrayList&lt;SomeClass&gt;(); try &#123; while (true)&#123; someClasses.add(new SomeClass()); &#125; &#125;catch (OutOfMemoryError e)&#123; System.out.println(\"Total instance created:\" + someClasses.size()); &#125; &#125;&#125; 这段代码很简单，我们在一个while循环中不停地new出SomeClass的对象，并将这个实例的引用保存到一个列表中以避免它被垃圾回收机制回收。下面是这段代码在我的笔记本电脑上的运行结果。 123456789101112131415161718[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;488K(6144K)] 5632K-&gt;3021K(19968K), 0.0047814 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 6120K-&gt;504K(6144K)] 8653K-&gt;7804K(19968K), 0.0066141 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] [Full GC (Ergonomics) [PSYoungGen: 6136K-&gt;0K(6144K)] [ParOldGen: 10465K-&gt;12311K(13824K)] 16601K-&gt;12311K(19968K), [Metaspace: 3496K-&gt;3496K(1056768K)], 0.1781231 secs] [Times: user=0.31 sys=0.00, real=0.18 secs] [Full GC (Ergonomics) [PSYoungGen: 4393K-&gt;2754K(6144K)] [ParOldGen: 12311K-&gt;13733K(13824K)] 16704K-&gt;16487K(19968K), [Metaspace: 3497K-&gt;3497K(1056768K)], 0.1530778 secs] [Times: user=0.86 sys=0.03, real=0.15 secs] [Full GC (Allocation Failure) [PSYoungGen: 2754K-&gt;2754K(6144K)] [ParOldGen: 13733K-&gt;13715K(13824K)] 16487K-&gt;16469K(19968K), [Metaspace: 3497K-&gt;3497K(1056768K)], 0.1069225 secs] [Times: user=0.58 sys=0.02, real=0.11 secs] java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid1940.hprof ...Heap dump file created [28250225 bytes in 0.123 secs]Total instance created:810325Heap PSYoungGen total 6144K, used 2921K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 51% used [0x00000000ff980000,0x00000000ffc5a568,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 13824K, used 13715K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000) object space 13824K, 99% used [0x00000000fec00000,0x00000000ff964d90,0x00000000ff980000) Metaspace used 3504K, capacity 4502K, committed 4864K, reserved 1056768K class space used 388K, capacity 390K, committed 512K, reserved 1048576K 首先可以看出设置了-verbose:gc参数之后，程序运行期间发生的GC操作的相关日志也被打印出来了。这部分内容我们会在之后的章节做具体分析，现在暂且略过。 然后是第一部分比较重要的打印java.lang.OutOfMemoryError: Java heap space。这行结果说明发生了内存溢出，具体溢出位置是Java虚拟机堆内存。 第二部分Dumping heap to java_pid1940.hprof …是因为我们设置了-XX:+HeapDumpOnOutOfMemoryError参数，这个参数的意思是在发生内存溢出的时候dump出当前堆内存的快照，Java自带的内存分析工具jhat可以对这个文件进行解析，并展示出堆内存按照类引用为区分的内存分配情况。具体如何使用JHat我们也会放到之后Java命令行工具一节再做详细介绍。当然有兴趣的同学可以自行查阅相关资料。 第三部分Total instance created:810325是由我们的代码打印的，可以看出直到堆内存被分配完毕并抛出OutOfMemoryError，我们一共创建了810325个SomeClass的实例。 第四部分则由虚拟机参数-XX:+PrintGCDetails控制，就是在程序运行完毕，打印出当前内存各个模块的使用情况。 堆内存溢出相对来说应该是比较常见的内存溢出异常，如果真的是因为内存泄漏，我们可以利用内存分析工具查看泄漏对象（这里说泄漏对象是指，在逻辑上已经不会再访问这个对象了，但是这个对象仍然被直接或间接的引用着，比如某个类中的静态引用）到GCRoots的引用链，这样就可以知道泄漏对象是通过怎样的的路径与GCroots（通常是指栈内存中的引用）相关联而导致垃圾收集器无法自动回收它们。找到了泄漏对象的类型信息以及引用链信息，就可以比较准确地定位泄漏代码的位置了。如果不存在内存泄漏，也就是说，内存中的每个对象实例确实都还必须存活，那么就应当检查虚拟机的堆参数（-Xms、-Xmx），根据具体的硬件条件看是否还可以调大。同时也检查代码看是否存在某些对象生命周期过长，持有状态时间过长的情况。尝试减少程序运行期的内存消耗。上述便是处理Java堆内存问题最基本，最简单的思路了。 虚拟机栈内存溢出 程序(每一个线程)运行期间，会有一个Java虚拟机栈，默认栈的大小为1M，用户也可以通过-Xss虚拟机参数设置栈的大小 Java虚拟机规范：如果请求的栈深度超过了虚拟机所允许的最大深度（其实LZ认为这个深度是相对的，深度=栈总大小/栈帧平均大小），将抛出StackOverFlow异常 如果虚拟机在扩展时无法申请到足够的内存空间，那么抛出OutOfMemoryError 再次声明，上面两个描述虽然做了区分，但是本质上是一样的，内存总的空间一定，当栈空间无法分配时，可以说内存太小，也可以说用于栈帧分配的空间太大。 具体应该抛出什么异常其实不是那么严格。因为栈帧深度也受限于栈的大小，可以说栈帧数目太多，当然也可以说内存太少。 实际测试中，使用-Xss参数减少栈内存容量，结果抛出StackOverFlow异常，异常出现时输出的栈深度相应缩小 实际测试中，如果为待调用方法定义大量局部变量，也就是说在内存分配时需要为这个方法的调用分配更大的栈帧，结果抛出StackOverFlowError，异常出现时输出的栈深度相应缩小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * VM Args:-Xss128k 当指定为128k，报异常：The stack size specified is too small, Specify at least 228k，LZ最小使用256k */public class StackOverFlow &#123; private int stackDeep; private void recursiveCall() &#123; this.stackDeep++; recursiveCall(); &#125; private static class RecursiveReference &#123; private RecursiveReference another; private static int referCount = 0; private void refer() &#123; referCount++; if (another != null) &#123; another.refer(); &#125; &#125; &#125; private static void recursiveReference() &#123; RecursiveReference currentRecursiveReference = new RecursiveReference(); RecursiveReference anotherRecursiveReference = new RecursiveReference(); currentRecursiveReference.another = anotherRecursiveReference; anotherRecursiveReference.another = currentRecursiveReference; currentRecursiveReference.refer(); &#125; private void recursiveCallWithBigStackFrame() &#123; this.stackDeep++; double occupyPositionA; double occupyPositionB; double occupyPositionC; recursiveCallWithBigStackFrame(); &#125; private static class RecursiveReferenceWithBigStackFrame &#123; private RecursiveReferenceWithBigStackFrame another; private static int referCount = 0; private void refer() &#123; referCount++; double occupyPositionA; double occupyPositionB; double occupyPositionC; if (another != null) &#123; another.refer(); &#125; &#125; &#125; private static void recursiveReferenceWithBigStackFrame() &#123; RecursiveReferenceWithBigStackFrame currentRecursiveReference = new RecursiveReferenceWithBigStackFrame(); RecursiveReferenceWithBigStackFrame anotherRecursiveReference = new RecursiveReferenceWithBigStackFrame(); currentRecursiveReference.another = anotherRecursiveReference; anotherRecursiveReference.another = currentRecursiveReference; currentRecursiveReference.refer(); &#125; public static void main(String[] args) &#123; StackOverFlow stackOverFlow = null; try &#123; stackOverFlow = new StackOverFlow(); stackOverFlow.recursiveCall(); &#125;catch (StackOverflowError e)&#123; //e.printStackTrace(); System.out.println(\"使用方法循环调用栈深度：\" + (stackOverFlow == null ? \"null\" : stackOverFlow.stackDeep)); &#125; try &#123; recursiveReference(); &#125;catch (StackOverflowError e)&#123; //e.printStackTrace(); System.out.println(\"使用对象循环引用栈深度：\" + RecursiveReference.referCount); &#125; try &#123; stackOverFlow = new StackOverFlow(); stackOverFlow.recursiveCallWithBigStackFrame(); &#125;catch (StackOverflowError e)&#123; //e.printStackTrace(); System.out.println(\"使用方法循环调用(分配较大的方法栈帧)栈深度：\" + (stackOverFlow == null ? \"null\" : stackOverFlow.stackDeep)); &#125; try &#123; recursiveReferenceWithBigStackFrame(); &#125;catch (StackOverflowError e)&#123; //e.printStackTrace(); System.out.println(\"使用对象循环引用(分配较大的方法栈帧)栈深度：\" + RecursiveReferenceWithBigStackFrame.referCount); &#125; &#125;&#125; 我们来看下测试代码，为了进行测试，我们使用了两种方式来产生StackOverFlowError，第一种是纯粹的递归调用。第二种是利用对象之间的循环引用。然后对于两种情况我们分别定义了没有局部变量和有局部变量的两种情况（对应较小栈帧和较大栈帧）。实际测试过程中我们使用的虚拟机参数分别为-Xss256k,-Xss1M以及不带参数-Xss，根据结果可以看出，当增大栈空间相应的栈帧数目即栈帧深度会变大（这个没有问题的，除法运算嘛）。大的栈帧相对于小栈帧在同等栈内存大小的情况下，较大栈帧调用只能得到较小的栈帧深度（也没有问题，同样是除法运算），此外，不带-Xss参数和带-Xss1M参数栈帧数目大抵相近（不知道为什么会有波动，而且即使内存相同，不同运行也会有不同的结果），这也验证了栈内存大小默认为1M。 1234567891011121314151617java8\\bin\\java -Xss256k ...使用方法循环调用栈深度：2994使用对象循环引用栈深度：2486使用方法循环调用(分配较大的方法栈帧)栈深度：1610使用对象循环引用(分配较大的方法栈帧)栈深度：1609java8\\bin\\java -Xss1M ...使用方法循环调用栈深度：19360使用对象循环引用栈深度：16078使用方法循环调用(分配较大的方法栈帧)栈深度：10409使用对象循环引用(分配较大的方法栈帧)栈深度：7380java8\\bin\\java ...使用方法循环调用栈深度：18243使用对象循环引用栈深度：11414使用方法循环调用(分配较大的方法栈帧)栈深度：10530使用对象循环引用(分配较大的方法栈帧)栈深度：7386 虚拟机栈内存溢出（基于线程实现）之前讨论过，单个线程下，无论是栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverFlowError。 当换到多线程的环境下，通过不断创建新的线程，可以产生内存溢出异常而不是StackOverFlowError，但是这样产生内存溢出异常与栈空间大小并无关系。或者准确地说这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出。为什么呢，因为这已经不再是一个Java虚拟机栈上的栈帧的分配问题了，而是整个虚拟机中剩余内存（总内存减去堆内存再减去永久代MaxPermSize内存）上的分配问题了。这部分剩余内存被虚拟机栈和本地方法栈瓜分，本地方法栈我们不会讨论。总结来说，我们不再是讨论如何通过分配栈帧来消耗虚拟机栈最终得到OutOfMemoryError或者StackOverFlowError，而是通过不断的分配一个一个的虚拟机栈来消耗这部分所谓的剩余内存最终得到OutOfMemoryError。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * VM Args:-Xss2M(这时候不妨设置大些) */public class StackOutOfMemory &#123; private boolean flag; private StackOutOfMemory() &#123; this.flag = true; &#125; private void stackMemoryLeakByThread() throws Exception &#123; final CountDownLatchWrapper countDownLatchWrapper = new CountDownLatchWrapper(); int threadCount = 0; try &#123; while (flag) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; try &#123; synchronized (StackOutOfMemory.class) &#123; StackOutOfMemory.class.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; countDownLatchWrapper.countDownLatch.countDown(); &#125; &#125;); thread.start(); threadCount++; &#125; &#125; catch (OutOfMemoryError outOfMemoryError) &#123; outOfMemoryError.printStackTrace(); countDownLatchWrapper.countDownLatch = new CountDownLatch(threadCount); this.flag = false; synchronized (StackOutOfMemory.class) &#123; StackOutOfMemory.class.notifyAll(); &#125; &#125; System.out.println(\"created:\" + threadCount + \" thread has been created! \" + new SimpleDateFormat(\"mm:ss.SSS\").format(new Date())); countDownLatchWrapper.countDownLatch.await(); System.out.println(\"all thread has finished! \" + new SimpleDateFormat(\"mm:ss.SSS\").format(new Date())); &#125; private static class CountDownLatchWrapper &#123; private CountDownLatch countDownLatch; &#125; public static void main(String[] args) throws Throwable &#123; StackOutOfMemory stackOutOfMemory = new StackOutOfMemory(); stackOutOfMemory.stackMemoryLeakByThread(); &#125;&#125; 代码依然很简单。不过有几个地方需要注意： 第一点，设置虚拟机参数-Xss2M，什么意思呢，就是将分配的虚拟机栈设置为2M。这样使用更少的线程就可以消耗完“剩余内存” 第二点，原书所附的源代码执行时会导致系统假死。因为为了保证分配的内存不被收集，需要new出来的子线程持续运行。最终虽然成功得到OutOfMemoryError异常，但是所有分配的内存都无法被回收，线程没有停止，每个线程占有最少2M的栈空间。最终其它应用程序因为无法分配内存也无法运行。所以本例中，利用Java的等待\\通知机制，我们在new线程的同时让线程阻塞在StackOutOfMemory.class类实例上，当发生utOfMemoryError异常时调用StackOutOfMemory.class.notifyAll()方法唤醒线程。让线程结束，并释放掉占有的内存。 第三点，利用CountDownLatch，当所有线程都结束的时候，打印线程全部结束的消息。 第四点，如果您使用的是伟大的视窗操作系统，请不要尝试运行此段代码（具体原因参见原文：特别提示一下，请如果读者尝试运行上面的代码，记得要先保存当前的工作， 由于在windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的，因此上述代码执行时有较大风险，可能导致系统假死），LZ运行了两次，idea均闪退，之后不久可能是内存被完全占用， 系统假死，只能强制重启，真是无fuck说，以下结果来自LinuxMint17.3 Idea2017 12345678910111213141516171819/usr/local/java/jdk1.8.0_73/bin/java -verbose:gc -XX:+PrintGCDetails -Xss2M java.lang.OutOfMemoryError: unable to create new native threadat java.lang.Thread.start0(Native Method)at java.lang.Thread.start(Thread.java:714)at com.jvm.memorymgn.StackOutOfMemory.stackMemoryLeakByThread(StackOutOfMemory.java:37)at com.jvm.memorymgn.StackOutOfMemory.main(StackOutOfMemory.java:66)created:31804 thread has been created! 38:29.804all thread has finished! 38:33.671HeapPSYoungGen total 150016K, used 38709K [0x0000000719100000, 0x0000000723800000, 0x00000007c0000000)eden space 129024K, 30% used [0x0000000719100000,0x000000071b6cd620,0x0000000720f00000)from space 20992K, 0% used [0x0000000722380000,0x0000000722380000,0x0000000723800000)to space 20992K, 0% used [0x0000000720f00000,0x0000000720f00000,0x0000000722380000)ParOldGen total 343040K, used 0K [0x00000005cb200000, 0x00000005e0100000, 0x0000000719100000)object space 343040K, 0% used [0x00000005cb200000,0x00000005cb200000,0x00000005e0100000)Metaspace used 3937K, capacity 4680K, committed 4864K, reserved 1056768Kclass space used 427K, capacity 432K, committed 512K, reserved 1048576K 方法区&amp;运行时常量池溢出之前也提打到过关于字符串常量的问题。本实例中使用的是String.intern()Api.不过由于LZ使用的java版本为1.8,而自1.7包括1.7之后Java虚拟机实现就把字符串常量池从永久代中移除了，所以并没有得到预期的异常，感兴趣得同学可以自行在1.6上面进行测试。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * VM Args:-XX:PermSize=10M-XX:MaxPermSize=10M LZ测试环境为java8,无法发生溢出 */public class RuntimeConstantPoolOutOfMemory &#123; public static void main(String[] args) &#123; //使用List保持着常量池引用,避免Full GC回收常量池行为 List&lt;String&gt; strPool = new ArrayList&lt;String&gt;(); long byteCount = 0; try &#123; //10MB的PermSize在integer范围内足够产生OOM了 int i = 0; String str; while (true) &#123; str = String.valueOf(i++); byteCount += str.length(); strPool.add(str.intern()); &#125; &#125;catch (OutOfMemoryError e)&#123; e.printStackTrace(); System.out.println(String.format(\"共创建了%s个字符串，共%s字节\",strPool.size(),byteCount)); &#125; &#125;&#125;//一个小实例，测试String.intern()以及StringBuilderpublic static void showJavaMagic()&#123; String str1 = new StringBuilder(\"计算机\").append(\"软件\").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder(\"ja\").append(\"va\").toString(); System.out.println(str2.intern() == str2);&#125;//1.8版本结果truefalse 直接内存溢出12345678910111213141516171819202122public class DirectMemoryOutOfMemory &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; int totalMemoryAllocated = 0; try &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); totalMemoryAllocated ++; &#125; &#125;catch (OutOfMemoryError e)&#123; e.printStackTrace(); System.out.println(\"目前一共分配了\" + totalMemoryAllocated + \"MB的内存！\"); &#125; &#125;&#125; 程序运行结果 1234567891011java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at com.jvm.memorymgn.DirectMemoryOutOfMemory.main(DirectMemoryOutOfMemory.java:21)Java HotSpot(TM) 64-Bit Server VM warning: Attempt to deallocate stack guard pages failed.Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00007f0fa3d98000, 12288, 0) failed; error='Cannot allocate memory' (errno=12)目前一共分配了2124252MB的内存！\\#\\# There is insufficient memory for the Java Runtime Environment to continue.\\# Native memory allocation (mmap) failed to map 12288 bytes for committing reserved memory.\\# An error report file with more information is saved as:\\# /home/icekredit/Documents/workplace/JvmTestCase/hs_err_pid9932.log","tags":[{"name":"Java","slug":"Java","permalink":"http://nxllxn.github.io/tags/Java/"},{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://nxllxn.github.io/tags/Java虚拟机/"},{"name":"JVM","slug":"JVM","permalink":"http://nxllxn.github.io/tags/JVM/"},{"name":"运行时数据区","slug":"运行时数据区","permalink":"http://nxllxn.github.io/tags/运行时数据区/"}]},{"title":"如何优雅的操作一个Json","date":"2017-07-17T11:59:22.997Z","path":"2017/07/17/java/java工具/NetSFJson/","text":"需求缘起JSON（JavaScript Object Notation）,是一种被广泛使用的后端数据处理以及前后端数据交互格式，本文将简要讨论一下如何中规中矩的操作一个JsonObject，从中读取数据，最后我也会简单介绍一下如何优雅地构建一个Json。 写在编码之前需求定义：1）从一个Json对象中读取Json属性，提供一个基本的读取函数get（返回值为Object），以及一些常用的类型如String，Double，Integer，Long，Boolean，JSONArray，JSONObject的读取函数2）为上述所有函数提供一个包含默认值的重载函数，当用户调用这个有默认值的函数时，编码更加清晰，程序的行为会更加明了3）虽然提供默认值程序会更加明了，但是上述两种解决方案还是可能导致大量空指针异常，为了对这个情况进行控制我们选择使用Optional（不了解的可参考guava类库以及Java8 Optional）来为上述函数统一提供一个Optional版本的重载（其实并不能叫重载，叫实现好一点，这里是为了凸显这三种实现的共性）。4）跨越多级Json取出指定属性5）原始的Json构造模式中代码不是很美观，而且如果你使用net.sf.json类库的话构造Json还可能出问题（之后会提到），所以本文最后会利用构造器模式来相对优雅地进行Json的组装。6）问题5中的一个问题，先声明，此问题只有net.sf.json中会出现，fastjson类库中没有上述问题。其它类库中TZ没有进行过研究。 编码首先是一个单例public class JSONTool { private JSONTool() { } private static class Holder { private static JSONTool jsonTool = new JSONTool(); } /** * 单例，才疏学浅，只会这么一个设计模式，哎 * * @return JsonTool对象 */ public static JSONTool getSingleInstance() { return Holder.jsonTool; } } 中规中矩的数据读取方式（包括带默认值的）/** * 判断当前Json对象中指定Key对应的json属性是否存在 * * @param dataJsonObj 当前jsonObject * @param key 指定json属性对应的key * @return 存在当前key返回true，否则返回false */ public Boolean isAttributeExists(JSONObject dataJsonObj, String key) { return !(dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) &amp;&amp; dataJsonObj.containsKey(key); } /** * 从当前json对象中取出指定key对应的布尔属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 返回指定key对应的布尔属性，如果指定key不存在或者不是一个有效的bool值，返回null */ public Boolean getBoolean(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } if (!REGUtil.REG_PATTERN_FOR_BOOLEAN.matcher(strValue).matches()) { return null; } return Boolean.valueOf(strValue); } /** * 从当前json对象中取出指定key对应的布尔属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 返回指定key对应的布尔属性，如果指定key不存在或者不是一个有效的bool值，返回defaultValue */ public Boolean getBoolean(JSONObject dataJsonObj, String key, Boolean defaultValue) { Boolean actualValue = getBoolean(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的双精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 如果指定key不存在或者不是一个有效的数值属性，返回null */ public Double getDouble(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(strValue).matches()) { return null; } return Double.valueOf(strValue.replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;)); } /** * 从指定Json对象中取出指定Key对应的数值属性值 * * @param dataJsonObj 指定Json对象 * @param key 指定Key * @param defaultValue 默认值 * @return 如果指定key对应的属性为有效的数值属性，那么返回此值，否则返回默认值defaultValue */ public Double getDouble(JSONObject dataJsonObj, String key, Double defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的金额属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 如果指定key不存在或者不是一个有效的金额属性，返回null */ public Double getAmount(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } String strValue = getString(dataJsonObj, key); if (StringUtils.isEmpty(strValue)) { return null; } //替换掉非数值字符 strValue = strValue.replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;); if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(strValue).matches()) { return null; } return Double.valueOf(strValue); } /** * 从指定Json对象中取出指定Key对应的金额属性值 * * @param dataJsonObj 指定Json对象 * @param key 指定Key * @param defaultValue 默认值 * @return 如果指定key对应的属性为有效的金额属性，那么返回此值，否则返回默认值defaultValue */ public Double getAmount(JSONObject dataJsonObj, String key, Double defaultValue) { Double actualValue = getAmount(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前对象中取出指定键对应的单精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的单精度浮点数属性，如果指定key不存在或者不是一个有效的数值属性，返回null */ public Float getFloat(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.floatValue(); } /** * 从当前对象中取出指定键对应的单精度浮点数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的单精度浮点数属性，如果指定key不存在或者不是一个有效的数值属性，返回默认值 */ public Float getFloat(JSONObject dataJsonObj, String key, Float defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.floatValue(); } /** * 从当前对象中取出指定键对应的属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的属性，如果不存在或发生异常返回null */ public Object get(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty()) { return null; } if (!dataJsonObj.containsKey(key)) { return null; } return dataJsonObj.get(key); } /** * 从当前对象中取出指定键对应的属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的属性，如果不存在返回默认值 */ public Object get(JSONObject dataJsonObj, String key, Object defaultValue) { Object actualValue = get(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前对象中取出指定键对应的整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者指定属性不是一个有效的数值属性那么返回null */ public Integer getInteger(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.intValue(); } /** * 从当前对象中取出指定键对应的整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者指定属性不是一个有效的数值属性那么返回默认值 */ public Integer getInteger(JSONObject dataJsonObj, String key, Integer defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.intValue(); } /** * 从当前对象中取出指定键对应的长整型整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者不是一个有效的数值属性那么返回null */ public Long getLong(JSONObject dataJsonObj, String key) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? null : actualValue.longValue(); } /** * 从当前对象中取出指定键对应的长整型整数属性 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的整数属性，如果指定key对应的属性不存在或者不是一个有效的数值属性那么返回默认值 */ public Long getLong(JSONObject dataJsonObj, String key, Long defaultValue) { Double actualValue = getDouble(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue.longValue(); } /** * 从当前对象中取出指定键对应的json数组 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定key对应的json数组，如果指定对应的属性不存在或者不是json数组返回null */ public JSONArray getJsonArray(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || !(obj instanceof JSONArray)) { return null; } return (JSONArray) obj; } /** * 从当前对象中取出指定键对应的json数组 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定key对应的json数组，如果指定对应的属性不存在或者不是Json数组返回默认值 */ public JSONArray getJsonArray(JSONObject dataJsonObj, String key, JSONArray defaultValue) { JSONArray actualValue = getJsonArray(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的json对象 * * @param dataJsonObj 当前json对象 * @param key 指定key * @return 指定key对应的json对象属性，如果指定对应的属性不存在或者不是json对象返回null */ public JSONObject getJsonObject(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || !(obj instanceof JSONObject)) { return null; } return (JSONObject) obj; } /** * 从当前json对象中取出指定键对应的json对象 * * @param dataJsonObj 当前json对象 * @param key 指定key * @param defaultValue 默认值 * @return 指定key对应的json对象属性，如果指定对应的属性不存在或者不是json对象返回默认值 */ public JSONObject getJsonObject(JSONObject dataJsonObj, String key, JSONObject defaultValue) { JSONObject actualValue = getJsonObject(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } /** * 从当前json对象中取出指定键对应的字符串 * * @param dataJsonObj 当前jsonObject * @param key 指定key * @return 指定键对应的字符串，如果不存在返回null */ public String getString(JSONObject dataJsonObj, String key) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)) { return null; } if (!dataJsonObj.containsKey(key)) { return null; } Object obj = get(dataJsonObj, key); if (obj == null || obj instanceof JSON) { return null; } return String.valueOf(obj); } /** * 从当前json对象中取出指定键对应的字符串 * * @param dataJsonObj 当前jsonObject * @param key 指定key * @param defaultValue 默认值 * @return 指定键对应的字符串，如果不存在或者指定key对应的属性是一个Json对象或者是Json数组返回默认值 */ public String getString(JSONObject dataJsonObj, String key, String defaultValue) { String actualValue = getString(dataJsonObj, key); return actualValue == null ? defaultValue : actualValue; } Optional方式的数据读取public Optional&lt;Object&gt; opt(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } return Option.of(get(dataJsonObj,key)); } public Optional&lt;String&gt; optString(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (obj instanceof JSON) { return Optional.empty(); } return Optional.of(String.valueOf(obj)); } /** * 返回Optional类型的Double属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Double属性 */ public Optional&lt;Double&gt; optDouble(JSONObject dataJsonObj,String key){ Optional&lt;String&gt; optStr = optString(dataJsonObj,key); if (!optStr.isPresent()){ return Optional.empty(); } if (!REGUtil.REG_PATTERN_FOR_NUMBER.matcher(optStr.get()).matches()) { return Optional.empty(); } return Optional.of(Double.valueOf(optStr.get().replaceAll(REGUtil.INVALID_FLOAT_CHAR_REG, &quot;&quot;))); } /** * 返回Optional类型的Float属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Float属性 */ public Optional&lt;Float&gt; optFloat(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::floatValue); } /** * 返回Optional类型的Integer属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Integer属性 */ public Optional&lt;Integer&gt; optInteger(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::intValue); } /** * 返回Optional类型的Long属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Long属性 */ public Optional&lt;Long&gt; optLong(JSONObject dataJsonObj,String key){ Optional&lt;Double&gt; optDouble = optDouble(dataJsonObj,key); return optDouble.map(Double::longValue); } /** * 返回Optional类型的Boolean属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的Boolean属性 */ public Optional&lt;Boolean&gt; optBoolean(JSONObject dataJsonObj,String key) { Optional&lt;String&gt; optStr = optString(dataJsonObj,key); if (!optStr.isPresent()){ return Optional.empty(); } if (StringUtils.isEmpty(optStr.get())) { return Optional.empty(); } if (!REGUtil.REG_PATTERN_FOR_BOOLEAN.matcher(optStr.get()).matches()) { return Optional.empty(); } return Optional.of(Boolean.valueOf(optStr.get())); } /** * 返回Optional类型的JsonObject属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的JsonObject属性 */ public Optional&lt;JSONObject&gt; optJsonObj(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (!(obj instanceof JSONObject)){ return Optional.empty(); } return Optional.of((JSONObject)obj); } /** * 返回Optional类型的JsonArray属性 * @param dataJsonObj 指定Json对象 * @param key 指定key * @return 指定key对应的JsonArray属性 */ public Optional&lt;JSONArray&gt; optJsonObjs(JSONObject dataJsonObj,String key){ if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(key)){ return Optional.empty(); } Optional&lt;Object&gt; optObj = opt(dataJsonObj,key); if (!optObj.isPresent()){ return Optional.empty(); } Object obj = optObj.get(); if (!(obj instanceof JSONArray)){ return Optional.empty(); } return Optional.of((JSONArray)obj); } 跨越多级取出指定属性private static final String FIELD_EXPRESSION_SEPARATOR = &quot;&gt;&quot;; /** * 从指定Json对象中取出指定表达式对应的属性 * * @param dataJsonObj 指定Json对象 * @param operandExpression 指定属性表达式 * @return 指定字段对应的属性 */ public static Object metaGet(JSONObject dataJsonObj, String operandExpression) { if (dataJsonObj == null || dataJsonObj.isEmpty() || StringUtils.isBlank(operandExpression)){ return null; } String[] operandExpressionParts = operandExpression.split(FIELD_EXPRESSION_SEPARATOR); Object obj = dataJsonObj; for (String operandExpressionPart : operandExpressionParts) { if (obj == null) { break; } if (obj instanceof JSONObject) { obj = ((JSONObject) obj).get(operandExpressionPart); continue; } if (obj instanceof JSONArray) { if (((JSONArray) obj).size() == 0) { return null; } obj = ((JSONArray) obj).get(0); if (obj instanceof JSONObject) { obj = ((JSONObject) obj).get(operandExpressionPart); } continue; } // 如果已经取到基本类型这一层了,但是表达式每一个小块儿还没用完,那么直接返回空,这是一个无效操作 return null; } return obj; } 构造Json/** * 构造器 */ public static class Builder { /** * 待构造Json对象 */ private Map&lt;String, Object&gt; currentMap; /** * 构造函数 */ public Builder() { this.currentMap = new HashMap&lt;&gt;(); } /** * 构造指定key-value-pair * * @param key 指定key * @param value 指定值 * @return 当前构造器对象 */ public Builder with(String key, Object value) { this.currentMap.put(key, value); return this; } /** * 构建Json对象 * * @return json对象 */ public JSONObject build() { return JSONObject.fromObject(this.currentMap); } } //使用方式 new JSONTool.Builder() .with(&quot;key_one&quot;,&quot;valueOne&quot;) .with(&quot;key_two&quot;,1) .with(&quot;key_three&quot;,true) .with(&quot;key_four&quot;,new JSONTool.Builder().with(&quot;sub_key_one&quot;,&quot;subValueOne&quot;).build()) .build(); net.sf.json的深复制问题大家应该也注意到上面的Builder中我并没有直接使用JsonObject作为属性，而是使用Map。为什么呢，我们看一下下面的例子，大家就明白了。 net.sf.jsonMap&lt;String, Object&gt; rootMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapOne = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapTwo = new HashMap&lt;&gt;(); subMapOne.put(&quot;map&quot;,subMapTwo); rootMap.put(&quot;map&quot;,subMapOne); System.out.println(rootMap); //{map={map={}}} subMapTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootMap); //{map={map={xxx=xxx}}} JSONObject rootJsonObj = new JSONObject(); JSONObject subJsonObjOne = new JSONObject(); JSONObject subJsonObjTwo = new JSONObject(); subJsonObjOne.put(&quot;json&quot;,subJsonObjTwo); rootJsonObj.put(&quot;json&quot;,subJsonObjOne); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} subJsonObjTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} What are you 弄啥嘞？ com.alibaba.fastjsonMap&lt;String, Object&gt; rootMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapOne = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; subMapTwo = new HashMap&lt;&gt;(); subMapOne.put(&quot;map&quot;,subMapTwo); rootMap.put(&quot;map&quot;,subMapOne); System.out.println(rootMap); //{map={map={}}} subMapTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootMap); //{map={map={xxx=xxx}}} JSONObject rootJsonObj = new JSONObject(); JSONObject subJsonObjOne = new JSONObject(); JSONObject subJsonObjTwo = new JSONObject(); subJsonObjOne.put(&quot;json&quot;,subJsonObjTwo); rootJsonObj.put(&quot;json&quot;,subJsonObjOne); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{}}} subJsonObjTwo.put(&quot;xxx&quot;,&quot;xxx&quot;); System.out.println(rootJsonObj); //{&quot;json&quot;:{&quot;json&quot;:{&quot;xxx&quot;:&quot;xxx&quot;}}} ：)","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"JSON工具","slug":"JSON工具","permalink":"http://nxllxn.github.io/tags/JSON工具/"},{"name":"JSONTool","slug":"JSONTool","permalink":"http://nxllxn.github.io/tags/JSONTool/"}]},{"title":"Linux 命令行","date":"2017-06-27T12:15:03.350Z","path":"2017/06/27/linux/linux命令行/LinuxCommandLine/","text":"启动，停止 启动： Ctrl + Alt + T 鼠标右键–&gt;在命令行中打开 停止： exit 文件系统跳转 pwd Print name of current working directory! 打印当前工作目录名称 cd Change Directory 更改当前工作目录路径 cd 无任何参数 更改当前工作目录到你的home目录 cd - 更改当前工作目录到先前工作目录 cd ～username 更改工作目录到指定用户主目录 探究操作系统 ls List current directory content 列出当前目录内容 ls -a/-all 列出所有文件，包括所有以.开头默认被隐藏的文件 ls -d/-directory 列出指定目录中的全部内容而不是当前目录 ls -F/-classify 此命令会为每个条目后面加上一个标识符，比如文件夹‘/’ ls -h/-human-readable 此命令以便于人眼阅读的模式展示文件信息，比如文件大小为KB或者，MB，而不是bytes ls -l 以长格式现实文件信息，一行一个文件 示例：-rw-r–r– 1 zhangsan zhangsan 0 4月1921:24 xx.ts -rw-r–r– 文件访问权限，开头的“-”说明是一个普通文件,“d”表明是一个目录。其后三个字符是文件所有者的访问权限,再其后的三个字符是文件所属组中成员的访问权限,最后三个字符是其他所有人的访问权限 1 文件硬连接的数目 zhangsan 文件所属用户名称 zhangsan 文件所属用户组名称 0 以字节数展示的文件大小 4月1921:24 最后一次文件修改时间 xx.ts 文件名称 ls -r/-reverse 以相反的顺序展示文件，默认是按照字母表升序展示 ls -S 输出文件按照文件大小排序 ls -t 输出文件按照修改时间排序 file 确定文件类型 file picture.jpg –&gt; picture.jpg: JPEG image data, JFIF standard 1.01 less 浏览文件 less somefile.txt 浏览指定文件 page up 向上翻滚一页 page down 向下翻滚一页 up arrow 向上翻滚一行 down arrow 向下翻滚一行 G 跳转到最后一行 1g/1G/g 跳转到第一行 /charaters 向前查找指定字符串 n 向前查找字符串，这个字符串是之前查找的 h 显示帮助屏幕 q 退出程序 more less is more(色即是空) less 相对与 more功能更加强大，more只支持分页浏览 一些常用目录 / 根目录，万物起源 /bin 包含系统启动和运行所必须的二进制程序 /boot linux 内核 /dev 一个包含设备文件的目录，linux中一切皆文件。 /etc 一些系统层面的配置文件 /etc/crontab 定义自动运行的任务 /etc/passwd 包含账户列表 /etc/hosts 主机配置信息 /etc/profile 系统环境变量 /etc/nginx/sites-available/default nginx配置文件位置，如果你用apt-get安装nginx的话 /home 通常，linux会在home目录下面为每一个用户创建一个目录，每个普通用户只能访问和操作自己用户目录下面的文件 /lib 系统运行所需要的核心类库 /media 挂载设备所在文件夹（一切皆文件） /root 管理员用户根目录 /sbin 包含系统二进制文件，通常为超级用户保留 /tmp 用于存储系统程序运行时的临时文件，某些系统配置会在系统启动时清空这个目录 /usr 包含普通用户所需要的程序和文件 /usr/bin 普通用户安装的文件 /usr/lib 普通用户共享的类库 /usr/local 通常用于安装从程序源码编译安装的软件 /var/log 系统日志所在文件 操作文件和目录 cp copy file and directory 复制文件和目录 mv move/rename files and directory 移动/重命名文件和目录 mkdir credit directories 创建目录 rm remove file and directory 移除文件和目录 ln create hard and symbolic links 创建硬连接和符号链接 通配符在介绍上面这些命令之前，我们首先一个使命令行无比强大的shell特性。因为shell命令需要频繁的使用文件名，所以shell提供了一组特殊字符用来快速指定某一组文件名，这些特殊字符就叫做通配符。 常见通配符 * 匹配任意多的字符（包括零个或者一个） ? 匹配任意一个字符（不包括零个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不再指定字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 [:alnum:] 匹配任意一个字母或者数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 常见通配符示例 * 全部文件 g* 所有以g开头的文件 b*.txt 以b开头中间有零个或者多个任意字符，并以.txt结尾的文件 Data??? 以Data开头，其后紧接着3个字符的文件 [abc]* 文件名以abc开头的文件 BACKUP.[0-9][0-9][0-9] 以BACKUP.开头并紧接着三个数字的文件 [[:upper:]]* 以大写字母开头的文件 *[[:lower:]123] 文件名以小写字母结尾或者是以1,2,3结尾 mkdir – 创建目录 mkdir directory 创建文件directory mkdir dir1 dir2 dir3 创建文件夹dir1,dir2,dir3 cp – 复制文件和目录 cp fromFileOrDir toFileOrDir 复制文件或文件夹fromFileOrDir到文件或文件夹toFileOrDir cp item1 item2 … toDirectory 复制多个文件到文件夹toDirectory 有用的选项 -a -archive 复制文件和目录，以及他们的属性，包括所有权和权限 -i -interactive 在重写已存在文件之前提示用户确认，如果不指定，cp命令会默认重写文件 -r -recursive 递归的复制目录以及目录中的内容，当复制目录的时候需要指定这个选项 -u -update 当复制文件时，只有在目标文件夹中不存在这个文件或者当前文件新于目标文件夹中的文件时才复制文件 -v -verbose 现实详细的命令操作信息 有用的示例 cp file1 file2 复制文件file1到file2,如果file2不存在那么创建，如果存在，那么覆盖 cp -i file2 file2 复制文件file1到file2,如果file2不存在那么创建，如果存在，那么提醒用户确认 cp file1 file2 dir 复制文件file1,file2到文件夹dir cp dir1/* dir2 复制文件夹1中的文件到dir2，dir2必须存在 cp -r dir1 dir2 递归复制文件夹dir1中的内容到dir2 mv 移动和重命名文件 mv fromFileOrDir toFileOrDir 移动（重命名）文件或文件夹fromFileOrDir到toFileOrDir mv item1 item2 … toDirectory 将一个或多个条目移动到另一个目录中 有用的选项 -i -interactive 在重写一个已经存在的文件之前，提示用户确认，如果不指定，mv命令会默认重写文件内容 -u -update 当把一个文件从一个目录移动到另一个目录时，只移动不存在的文件，或者较新的文件 -v -verbose 显示详细的信息 有用的示例 mv file1 file2 移动文件file1到file2,如果file2不存在直接复制，否则覆盖文件 mv -i file1 file2 移动文件file1到file2,如果file2不存在直接复制，否则提用户确认 mv file1 file2 dir 移动file1,file2到文件夹dir中，dir必须已经存在 mv dir1 dir2 如果dir2不存在，那么新建dir2,并且移动dir1中的内容到dir2,然后删除dir1。如果dir2存在，移动dir1中的内容到dir2. rm – 删除文件和目录 rm item1 item2 。。。 删除一个或多个文件或目录 选项 -i -interactive 在删除已经存在的文件前，提示用户确认，不然，此命令会默默删除文件 -r -recursive 递归的删除文件,用于删除目录 -f -force 不显示任何提示信息，同-interactive命令相反 -v -verbose 现实详细的操作信息 命令 rm file1 默默地删除文件file1 rm -i file1 删除文件之前，提醒用户确认 rm -r file1,dir1 删除文件file1,递归的删除文件夹dir1中的全部内容（文件以及dir） rm -rf file1,dir1 同上，如果file1或者dir1不存在，此命令仍然会执行 ln – 创建链接 ln file link 创建一个硬连接 ln -s file link 创建一个软链接 硬链接 硬连接和符号链接比起来，硬连接是最初Unix创建链接的方式，而符号链接更加现代，在默认情况下，每个文件有一个硬链接，这个硬链接给文件起名字。当我们创建了一个硬链接之后，就为文件创建了一个额外的目录条目。 一个硬链接不能关联它所在文件系统之外的其他文件，这是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件。 一个硬连接不能关联一个目录 一个硬链接和文件本身没有什么区别。不像符号链接,当你列出一个包含硬链接的目录内容时,你会看到没有特殊的链接指示说明。当一个硬链接被删除时,这个链接被删除,但是文件本身的内容仍然存在(这是说,它所占的磁盘空间不会被重新分配),直到所有关联这个文件的链接都删除掉。 *符号链接 一个符号链接指向一个文件,而且这个符号链接本身与其它的符号链接几乎没有区别。例如,如果你往一个符号链接里面写入东西,那么相关联的文件也被写入。然而,当你删除一个符号链接时,只有这个链接被删除,而不是文件自身。如果先于符号链接删除文件,这个链接仍然存在,但是不指向任何东西。在这种情况下,这个链接被称为坏链接。 使用命令 什么是命令 命令可以是一个可执行程序，例如任何在位于/usr/bin中的文件,java,python等 内建与shell自身的命令，或者说shell内部命令 shell脚本，其通常包含一组想关联的shell命令，共同完成某项功能 一个命令别名（网络上有一些很有意思的整蛊的文章，比如将ls命令作为rm -rf命令的别名，这样就不是列出一个文件夹的内容了，而是默默删除整个文件夹） 识别命令–type type command command 是需要识别的命令名称 icekredit@IceKredit ~ $ type type type is a shell builtin icekredit@IceKredit ~ $ type ls ls is aliased to `ls --color=auto&apos; icekredit@IceKredit ~ $ type cp cp is /bin/cp icekredit@IceKredit ~ $ type java java is /usr/local/java/jdk1.8.0_73/bin/java 显示一个可执行程序的位置 icekredit@IceKredit ~ $ which ls /bin/ls icekredit@IceKredit ~ $ which cp /bin/cp icekredit@IceKredit ~ $ which java /usr/local/java/jdk1.8.0_73/bin/java 此命令只对可执行程序有效 得到shell内部命令的帮助文档 icekredit@IceKredit ~ $ help cd cd: cd [-L|[-P [-e]] [-@]] [dir] Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option `cdable_vars&apos; is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed: resolve symbolic links in DIR after processing instances of `..&apos; -P use the physical directory structure without following symbolic links: resolve symbolic links in DIR before processing instances of `..&apos; -e if the -P option is supplied, and the current working directory cannot be determined successfully, exit with a non-zero status -@ on systems that support it, present a file with extended attributes as a directory containing the file attributes The default is to follow symbolic links, as if `-L&apos; were specified. `..&apos; is processed by removing the immediately previous pathname component back to a slash or the beginning of DIR. Exit Status: Returns 0 if the directory is changed, and if $PWD is set successfully when -P is used; non-zero otherwise. *出现在命令语法说明中的方括号表示可选的项目，一个竖杠字符表示互斥选项 显示程序手册 – –help icekredit@IceKredit ~ $ mkdir –help Usage: mkdir [OPTION]… DIRECTORY… Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z, --context=CTX set the SELinux security context of each created directory to CTX --help display this help and exit --version output version information and exit 显示程序手册 – man 大多数系统中，man使用less程序显示参考手册 显示适当的命令 – apropos 基于关键字进行匹配 icekredit@IceKredit ~ $ apropos diskarm_sync_file_range (2) - sync a file segment with diskbaobab (1) - A graphical tool to analyze disk usagecfdisk (8) - display or manipulate disk partition tablecgdisk (8) - Curses-based GUID partition table (GPT) manipulatorcryptdisks_start (8) - wrapper around cryptsetup that parses /etc/crypttab.cryptdisks_stop (8) - wrapper around cryptsetup that parses /etc/crypttab.df (1) - report file system disk space usage。。。 显示非常简洁的命令说明 – whatis icekredit@IceKredit ~ $ whatis ls ls (1) - list directory contents 显示程序info条目 – info 可以将多个命令放在一行，用多个分号分隔 为一个或多个命令创建别名 icekredit@IceKredit ~ $ alias foo=’cd /usr; ls; cd -‘ icekredit@IceKredit ~ $ type foo foo is aliased to `cd /usr; ls; cd -‘ 删除别名 icekredit@IceKredit ~ $ type foo foo is aliased to `cd /usr; ls; cd -‘ icekredit@IceKredit ~ $ unalias foo icekredit@IceKredit ~ $ type foo bash: type: foo: not found","tags":[{"name":"linux","slug":"linux","permalink":"http://nxllxn.github.io/tags/linux/"},{"name":"linux 命令行","slug":"linux-命令行","permalink":"http://nxllxn.github.io/tags/linux-命令行/"},{"name":"linux shell","slug":"linux-shell","permalink":"http://nxllxn.github.io/tags/linux-shell/"}]},{"title":"如何优雅地实现一个Java日期转换工具","date":"2017-05-27T07:26:45.951Z","path":"2017/05/27/java/java工具/DateTool/","text":"需求缘起 日常编程过程中或多或少需要用到日期转换相关的功能，比如常用格式相关的日期格式化为字符串或者是字符串转日期对象等，甚至有的时候需要一个兼容较多日期格式的字符串转日期方法，本文中我会实现一个基本满足上述功能的简单工具。 为什么要实现为一个工具而不是一个工具类呢。首先声明工具类和工具是有区别的，工具类是指XXXUtil这种命名的类，其内部通常包含一组功能相近或者相似的静态工具函数，注意了这里是静态工具函数。而工具是指以XXXTool这种命名的类，这种类通常是可实例化的，且内部有一组功能相近或者相似的实例方法。好吧，扯了这么多，其实大概意思就是我会用上一点点面向对象的设计思路。具体为什么要这样，看完本文你就会大概了解我的初衷的。 写在编码之前任何一份好的代码都必然是经过两次加工，第一次是在脑子里面，我不建议拿到需求就里面开始编码，首先你要把需求整个过一遍，在大脑里面有个大概的思路，此外，程序是写来处理异常情况的，为什么有“测试驱动编程”，就是我们先明确我们的代码需要处理的全部流程，需要的功能是什么，有哪些异常情况需要处理等等，做到这一步才能说我们理解了需求。 基本功能，基本的字符串转日期功能，基本的日期格式化为字符串功能，一个可以兼容多种日期格式的字符串转日期功能。 为了方便使用，可以为一些常用的格式转换提供默认实现 面向对象编程，提供一组接口，提供这个接口的不同实现，为什么不同？之后再告诉你！ 单例，我计划将这个工具设计为一个单例 线程安全，每次new一个日期转换工具类太麻烦而且浪费资源，我们会对日期格式化相关的对象做一个“缓存”。什么缓存，直接维护几个全局静态的实例不就好了吗？不！SimpleDateFormat不是线程安全的，在并发环境下这种实现就会出问题。那正确的姿势是什么呢？本文中我会使用ThreadLocal！ 单元测试，这里把单元测试列为设计实现的一部分，首先单元测试的重要性我们就不说了，主要是代码写完了，是骡子是马，总得遛一遛看一下对不对。 编码接口定义不多说了，直接上代码 public interface DateTool { /** * 日志TAG */ String TAG = &quot;DateTool&quot;; /** * 默认的日期格式 */ String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; /** * 默认月份格式 */ String DEFAULT_MONTH_FORMAT = &quot;yyyy-MM&quot;; /** * 默认年份格式 */ String DEFAULT_YEAR_FORMAT = &quot;yyyy&quot;; /** * 默认的时间格式 */ String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; /** * 默认的日期时间格式 */ String DEFAULT_DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; /** * 如果字符串长度为8位，且都是字符串，那么我们认为这是一个yyyyMMdd格式的日期 */ Pattern FULL_DATE_PATTERN = Pattern.compile(&quot;[0-9]{8}&quot;); //20120101 /** * 日期分隔符 */ String DATE_NOTIFIER_PATTERN_STR = &quot;[年月日\\\\-/.]+&quot;; /** * 时间分隔符 */ String TIME_NOTIFIER_PATTERN_STR = &quot;[时分秒点:]+&quot;; /** * 压缩的时间日期格式 */ String DATA_TIME_FORMAT = &quot;yyyyMMddHHmmss&quot;; /** * 压缩的日期格式 */ String DATA_FORMAT = &quot;yyyyMMdd&quot;; /** * 压缩的时间格式 */ String TIME_FORMAT = &quot;HHmmss&quot;; Pattern REG_PATTERN_FOR_DATE = Pattern.compile( &quot;((^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(10|12|0?[13578])([-/\\\\._])(3[01]|[12][0-9]|0?[1-9]).*$)&quot; + &quot;|(^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(11|0?[469])([-/\\\\._])(30|[12][0-9]|0?[1-9]).*$)&quot; + &quot;|(^((1[8-9]\\\\d{2})|([2-9]\\\\d{3}))([-/\\\\._])(0?2)([-/\\\\._])(2[0-8]|1[0-9]|0?[1-9]).*$)&quot; + &quot;|(^([2468][048]00)([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([3579][26]00)([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][0][48])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][0][48])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][2468][048])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][2468][048])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([1][89][13579][26])([-/\\\\._])(0?2)([-/\\\\._])(29).*$)&quot; + &quot;|(^([2-9][0-9][13579][26])([-/\\\\._])(0?2)([-/\\\\._])(29).*$))&quot;); /** * 使用指定格式化字符转换指定日期字符串 * * @param dateTimeStr 指定日期字符串 * @return 转换后得到的date */ Date parse(String dateTimeStr) throws Exception ; /** * 使用指定格式化字符转换指定日期字符串 * * @param dateString 指定日期字符串 * @param parseStr 指定格式化字符 * @return 转换后得到的date */ Date parse(String parseStr, String dateString) throws Exception ; /** * 按照指定字符串格式格式化指定日期 * @param pattern 字符串格式 * @param date 指定日期 * @return 格式化后的字符串 */ String format(String pattern, Date date) throws Exception ; /** * 使用默认日期格式转换指定日期字符换 * * @param dateString 指定日期字符串 * @return 转换后得到的date */ Date parseDate(String dateString) throws Exception ; /** * 使用默认日期格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatDate(Date date) throws Exception ; /** * 使用默认时间格式转换时间字符串 * * @param dateString 时间字符串 * @return 转换后得到的date */ Date parseTime(String dateString) throws Exception ; /** * 使用默认时间格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatTime(Date date) throws Exception ; /** * 使用默认格式转换指定日期时间字符串 * * @param dateString 指定日期时间字符串 * @return 转换后得到的date */ Date parseDateTime(String dateString) throws Exception ; /** * 使用默认日期时间格式格式化date * * @param date 指定date * @return 格式化后的字符串 */ String formatDateTime(Date date) throws Exception ; } 里面有比较详细的JavaDoc，我大概说一下 程序开始定义了一些常用的日期格式字符串常量 接下来是相关接口一共有9个接口： Date parse(String dateTimeStr);兼容多种日期格式的字符串转日期接口 Date parse(String parseStr, String dateString) ;使用指定格式化字符parseStr转换指定日期字符串dateString Date parseDate(String dateString) ; 使用默认日期格式转换指定日期字符换 Date parseTime(String dateString) ; 使用默认时间格式转换时间字符串 Date parseDateTime(String dateString) ; 使用默认日期时间格式转换指定日期时间字符串 String format(String pattern, Date date); 按照指定字符串格式格式化指定日期 String formatDate(Date date); 使用默认日期格式格式化date String formatTime(Date date) ; 使用默认时间格式格式化date String formatDateTime(Date date); 使用默认日期时间格式格式化date 一个字，清晰！明了！好了接下来就是具体实现了。 ThreadLocal实现时间转换格式“缓存”还是先上代码 public class BaseDateTool { /** * ThreadLocal 对象,用于存储当前线程中使用的日期格式化对象 */ private static final ThreadLocal convertDataFormatThreadLocal = new ThreadLocal(); /** * 获取或者实例化一个指定字符串格式对应的SimpleDateFormat对象 * @param pattern 格式化字符串 * @return 格式化字符串对应的SimpleDateFormat格式化对象 */ protected SimpleDateFormat getDateFormat(String pattern) throws Exception{ Map&lt;String,SimpleDateFormat&gt; map = (Map&lt;String, SimpleDateFormat&gt;) convertDataFormatThreadLocal.get(); if(map == null){ map = new HashMap&lt;&gt;(); map.put(pattern,new SimpleDateFormat(pattern)); convertDataFormatThreadLocal.set(map); } if(!map.containsKey(pattern)){ map.put(pattern,new SimpleDateFormat(pattern)); } return map.get(pattern); } } 这是具体实现类的一个基类，既然接口都抽出来了，把这一块功能抽离到一个基类里面好像也不过份吧。简单解释一下，首先声明了一个全局的静态的final的ThreadLocal对象，不用说了，我们用于日期转换格式化的SimpleDateFormat对象就会放到这里面。那么问题来了，怎么放呢，实际编码过程中，可能遇到各种类型的日期格式需要进行格式化或者转换。所以我们用一个Map来存储这些对象，key为实际的字符串格式，值为当前字符串格式对应的日期转换格式化对象，如果Map中已经存在了指定字符串格式的key，那么直接将这个key对应的对象返回，否则先new一个当前格式的对象，然后插入到Map中并返回。 具体实现老规矩，先上代码。 public class DateToolImpl extends BaseDateTool implements DateTool{ private DateToolImpl(){} private static class Holder{ private static final DateTool dateTool = new DateToolImpl(); } public static DateTool getSiingleInstance(){ return Holder.dateTool; } @Override public Date parse(String dateTimeStr) throws Exception { if (StringUtils.isEmpty(dateTimeStr)) { return null; } dateTimeStr = dateTimeStr.replaceAll(&quot;\\\\.\\\\d{3}&quot;, &quot;&quot;); //去除掉毫秒部分 String dateStr = null; String timeStr = null; String[] dateTimeStrParts = dateTimeStr.split(&quot;[ \\\\n]&quot;); for (String dateTimeStrPart : dateTimeStrParts) { if (REG_PATTERN_FOR_DATE.matcher(dateTimeStrPart).matches() || dateTimeStrPart.contains(&quot;年&quot;) || dateTimeStrPart.contains(&quot;月&quot;) || dateTimeStrPart.contains(&quot;日&quot;) || dateTimeStrPart.contains(&quot;-&quot;) || dateTimeStrPart.contains(&quot;/&quot;) || dateTimeStrPart.contains(&quot;.&quot;) || FULL_DATE_PATTERN.matcher(dateTimeStrPart).matches() || dateTimeStrPart.length() == 4) { dateStr = dateTimeStrPart; } else { timeStr = dateTimeStrPart; } } StringBuilder dateBuilder = new StringBuilder(); if (!StringUtils.isEmpty(dateStr)) { String[] dateParts = dateStr.split(DATE_NOTIFIER_PATTERN_STR); for (String datePart : dateParts) { if (datePart.length() == 1) { dateBuilder.append(&quot;0&quot;); } dateBuilder.append(datePart); } switch (dateBuilder.length()) { case 4: dateBuilder.append(&quot;0101&quot;); break; case 6: dateBuilder.append(&quot;01&quot;); break; } } StringBuilder timeBuilder = new StringBuilder(); if (!StringUtils.isEmpty(timeStr)) { String[] timeParts = timeStr.split(TIME_NOTIFIER_PATTERN_STR); for (String timePart : timeParts) { if (timePart.length() == 1) { timeBuilder.append(&quot;0&quot;); } timeBuilder.append(timePart); } switch (timeBuilder.length()) { case 2: timeBuilder.append(&quot;0000&quot;); break; case 4: timeBuilder.append(&quot;00&quot;); break; } } String formattedDateStr = dateBuilder.toString(); String formattedTimeStr = timeBuilder.toString(); if (StringUtils.isEmpty(formattedDateStr) &amp;&amp; StringUtils.isEmpty(formattedTimeStr)) { return null; } if (StringUtils.isEmpty(formattedDateStr)) { return parse(TIME_FORMAT,formattedTimeStr); } if (StringUtils.isEmpty(formattedTimeStr)) { return parse(DATA_FORMAT,formattedDateStr); } return parse(DATA_TIME_FORMAT,formattedDateStr + formattedTimeStr); } @Override public Date parse(String parseStr, String dateString) throws Exception { if(StringUtils.isEmpty(parseStr) || StringUtils.isEmpty(dateString)){ return null; } return getDateFormat(parseStr).parse(dateString); } @Override public String format(String pattern, Date date) throws Exception { if(StringUtils.isEmpty(pattern) || date == null){ return null; } return getDateFormat(pattern).format(date); } @Override public Date parseDate(String dateString) throws Exception { return parse(DEFAULT_DATE_FORMAT, dateString); } @Override public String formatDate(Date date) throws Exception { return format(DEFAULT_DATE_FORMAT, date); } @Override public Date parseTime(String dateString) throws Exception { return parse(DEFAULT_TIME_FORMAT, dateString); } @Override public String formatTime(Date date) throws Exception { return format(DEFAULT_TIME_FORMAT, date); } @Override public Date parseDateTime(String dateString) throws Exception { return parse(DEFAULT_DATETIME_FORMAT, dateString); } @Override public String formatDateTime(Date date) throws Exception { return format(DEFAULT_DATETIME_FORMAT, date); } } 具体实现细节我就不再多讲了，上面的每个实现都不是很复杂。 测试DateTool dateTool = DateToolImpl.getSingleInstance(); @Test @SuppressWarnings(&quot;unchecked&quot;) public void testIntelligentParse(){ assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;20120202&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-02&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-2&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年2月2日&quot;).toString()); assertEquals(&quot;Thu Feb 02 01:01:01 CST 2012&quot;,dateTool.parse(&quot;2012-02-02 01:01:01&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012/02/02&quot;).toString()); assertEquals(&quot;Thu Feb 02 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012-02-02&quot;).toString()); assertEquals(&quot;Thu Jan 01 20:12:02 CST 1970&quot;,dateTool.parse(&quot;201202&quot;).toString()); assertEquals(&quot;Sun Jan 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012&quot;).toString()); assertEquals(&quot;Sun Jan 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012年02月&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012.02.01&quot;).toString()); assertEquals(&quot;Wed Feb 01 00:00:00 CST 2012&quot;,dateTool.parse(&quot;2012.02&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:11:11 CST 1970&quot;,dateTool.parse(&quot;11:11:11&quot;).toString()); assertEquals(&quot;Thu Jan 01 01:01:01 CST 1970&quot;,dateTool.parse(&quot;1:1:1&quot;).toString()); assertEquals(&quot;Thu Jan 01 01:01:01 CST 1970&quot;,dateTool.parse(&quot;01:01:01&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:11:00 CST 1970&quot;,dateTool.parse(&quot;11:11&quot;).toString()); assertEquals(&quot;Thu Jan 01 11:00:00 CST 1970&quot;,dateTool.parse(&quot;11&quot;).toString()); } 结果：上面的单元测试都可以通过 //测试多线程 public static void main(String[] args) { DateTool dateTool = DateToolImpl.getSingleInstance(); for (int index = 0;index &lt; 10;index ++){ new Thread(() -&gt; { String currentThreadName = Thread.currentThread().getName(); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;20120202&quot;)); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;11:11:11&quot;)); System.out.println(currentThreadName + &quot; &quot; + dateTool.parse(&quot;2012年02月02日 11:11:11&quot;)); }).start(); } } 结果： Thread-7 Thu Feb 02 00:00:00 CST 2012 Thread-8 Thu Feb 02 00:00:00 CST 2012 Thread-2 Thu Feb 02 00:00:00 CST 2012 Thread-7 Thu Jan 01 11:11:11 CST 1970 Thread-2 Thu Jan 01 11:11:11 CST 1970 Thread-3 Thu Feb 02 00:00:00 CST 2012 Thread-5 Thu Feb 02 00:00:00 CST 2012 Thread-3 Thu Jan 01 11:11:11 CST 1970 Thread-5 Thu Jan 01 11:11:11 CST 1970 Thread-6 Thu Feb 02 00:00:00 CST 2012 Thread-0 Thu Feb 02 00:00:00 CST 2012 Thread-3 Thu Feb 02 11:11:11 CST 2012 Thread-2 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Feb 02 00:00:00 CST 2012 Thread-4 Thu Feb 02 00:00:00 CST 2012 Thread-1 Thu Feb 02 00:00:00 CST 2012 Thread-0 Thu Jan 01 11:11:11 CST 1970 Thread-7 Thu Feb 02 11:11:11 CST 2012 Thread-1 Thu Jan 01 11:11:11 CST 1970 Thread-8 Thu Jan 01 11:11:11 CST 1970 Thread-0 Thu Feb 02 11:11:11 CST 2012 Thread-1 Thu Feb 02 11:11:11 CST 2012 Thread-8 Thu Feb 02 11:11:11 CST 2012 Thread-6 Thu Jan 01 11:11:11 CST 1970 Thread-5 Thu Feb 02 11:11:11 CST 2012 Thread-4 Thu Jan 01 11:11:11 CST 1970 Thread-6 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Jan 01 11:11:11 CST 1970 Thread-4 Thu Feb 02 11:11:11 CST 2012 Thread-9 Thu Feb 02 11:11:11 CST 2012 为什么要定义接口我们为需要实现的功能定义了接口，并提供了一种实现。但是有些时候可能需要另一种实现。比如java8中提供了一组新的Date Api，比如日期格式化类DateTimeFormatter。如果我们希望利用Java8 Date api做一个新的实现，那么就可以在不改变原来代码的情况下直接扩展一个实现就好了。 结语只是一个小demo，代码写的不好，有什么问题恳请批评指正，感激涕零！此外，请轻喷！ 参考资料深入理解Java：SimpleDateFormat安全的时间格式化","tags":[{"name":"java","slug":"java","permalink":"http://nxllxn.github.io/tags/java/"},{"name":"日期转换工具","slug":"日期转换工具","permalink":"http://nxllxn.github.io/tags/日期转换工具/"},{"name":"日期格式化工具","slug":"日期格式化工具","permalink":"http://nxllxn.github.io/tags/日期格式化工具/"},{"name":"DateTool","slug":"DateTool","permalink":"http://nxllxn.github.io/tags/DateTool/"}]},{"title":"随笔","date":"2017-05-19T03:08:48.971Z","path":"2017/05/19/essay/essay/","text":"不如意事常八九，可与人言无二三。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://nxllxn.github.io/tags/随笔/"}]}]